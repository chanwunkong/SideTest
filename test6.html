<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HoldFocus - v10.12 Final Precision</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- 基礎樣式 --- */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }

        #file-upload {
            display: none;
        }

        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .checkerboard {
            background-color: #f0f0f0;
            background-image: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .color-btn.selected {
            ring: 2px;
            ring-offset: 2px;
            ring-color: #3b82f6;
            transform: scale(1.15);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* --- 架構樣式 --- */
        .canvas-stack {
            position: relative;
            width: 0;
            height: 0;
        }

        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #layer-bg {
            z-index: 1;
        }

        #layer-mask {
            z-index: 2;
            mix-blend-mode: normal;
        }

        #layer-ui {
            z-index: 3;
            pointer-events: none;
        }

        /* Fixed Crop Overlay */
        .crop-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .crop-frame {
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            position: relative;
            display: none;
        }

        .crop-frame::before {
            content: '';
            position: absolute;
            top: 33.33%;
            left: 0;
            right: 0;
            height: 33.33%;
            border-top: 1px dashed rgba(255, 255, 255, 0.3);
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .crop-frame::after {
            content: '';
            position: absolute;
            left: 33.33%;
            top: 0;
            bottom: 0;
            width: 33.33%;
            border-left: 1px dashed rgba(255, 255, 255, 0.3);
            border-right: 1px dashed rgba(255, 255, 255, 0.3);
        }

        #crop-inner-backdrop {
            position: absolute;
            inset: 0;
            z-index: 0;
            transition: background-color 0.2s;
            display: none;
        }

        .tool-btn.active {
            background-color: #2563eb;
            color: white;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        .tool-btn {
            color: #6b7280;
            transition: all 0.2s;
        }

        .tool-btn:hover:not(.active) {
            background-color: #f3f4f6;
            color: #111827;
        }

        .snap-line {
            position: absolute;
            background-color: #3b82f6;
            z-index: 70;
            pointer-events: none;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .slider-btn {
            width: 22px;
            height: 22px;
            border-radius: 6px;
            background: #f3f4f6;
            color: #4b5563;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .slider-btn:hover {
            background: #e5e7eb;
            color: #111827;
        }

        .slider-btn:active {
            background: #d1d5db;
            transform: scale(0.95);
        }

        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }

        .toggle-checkbox:checked+.toggle-label {
            background-color: #3b82f6;
        }

        .list-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .list-item:hover {
            border-color: #bfdbfe;
        }

        #loupe {
            position: absolute;
            width: 120px;
            height: 120px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: none;
            background: #000;
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 h-screen flex flex-col overflow-hidden font-sans">

    <!-- Header -->
    <header
        class="bg-white border-b border-gray-200 h-14 flex items-center justify-between px-4 shrink-0 z-20 shadow-sm">
        <div class="flex items-center gap-2 overflow-hidden">
            <h1 class="text-base font-bold text-gray-900 truncate">HoldFocus <span
                    class="text-xs font-normal text-gray-500 ml-1">v10.12 Final</span></h1>
            <div class="flex ml-4 border-l border-gray-200 pl-4 space-x-1">
                <button id="undo-btn"
                    class="p-1.5 text-gray-500 hover:text-gray-900 rounded hover:bg-gray-100 disabled:opacity-30 transition-colors"
                    disabled title="Undo">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                    </svg>
                </button>
                <button id="redo-btn"
                    class="p-1.5 text-gray-500 hover:text-gray-900 rounded hover:bg-gray-100 disabled:opacity-30 transition-colors"
                    disabled title="Redo">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div class="flex space-x-2 items-center">
            <label for="file-upload"
                class="cursor-pointer bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1.5 rounded text-sm font-medium transition-colors">開啟</label>
            <input id="file-upload" type="file" accept="image/*">
            <button id="download-btn"
                class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded text-sm font-medium transition-colors disabled:opacity-50 shadow-sm"
                disabled>下載</button>
        </div>
    </header>

    <main class="flex-1 flex flex-col-reverse md:flex-row overflow-hidden relative">

        <!-- Sidebar -->
        <aside
            class="w-full md:w-80 bg-white border-t md:border-t-0 md:border-r border-gray-200 flex flex-col z-10 shrink-0 h-[40%] md:h-full transition-all duration-300 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] md:shadow-none">
            <div class="flex border-b border-gray-200 shrink-0">
                <button id="tab-route"
                    class="flex-1 py-3 text-sm font-bold text-blue-600 border-b-2 border-blue-600 bg-blue-50 transition-colors">路線編輯</button>
                <button id="tab-text"
                    class="flex-1 py-3 text-sm font-medium text-gray-500 hover:text-gray-700 transition-colors">文字/標記</button>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar relative p-4">
                <!-- Panel: Route -->
                <div id="panel-route" class="space-y-4">
                    <div class="bg-blue-50 border border-blue-100 rounded-lg p-3 text-center md:text-left">
                        <p class="text-sm text-blue-800 font-medium leading-relaxed">1. 右上角開啟照片<br>2. 點擊下方 <b
                                class="inline-flex items-center justify-center w-5 h-5 bg-blue-600 text-white rounded-full text-xs mx-0.5 align-middle shadow-sm">+</b>
                            號，開始圈選岩點</p>
                    </div>

                    <!-- Selection List -->
                    <div class="flex-1 flex flex-col min-h-0">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-bold text-gray-700">已選岩點</h3>
                        </div>
                        <div id="color-list" class="space-y-2 pb-2 overflow-y-auto pr-1">
                            <div
                                class="text-center py-8 text-gray-400 text-sm italic border-2 border-dashed border-gray-100 rounded-lg">
                                尚未圈選</div>
                        </div>
                    </div>

                    <!-- Eraser Size Control -->
                    <div id="brush-controls" class="hidden border-t border-gray-200 pt-4">
                        <div class="flex justify-between mb-1"><label
                                class="text-xs font-bold text-blue-800 uppercase tracking-wider">橡皮擦大小</label><span
                                id="brush-size-val" class="text-xs text-blue-600 font-mono">20px</span></div>
                        <div class="slider-group">
                            <button class="slider-btn" onclick="app.adjSlider('brush-size', -5)">-</button>
                            <input type="range" id="brush-size" min="5" max="100" value="20" class="accent-blue-600">
                            <button class="slider-btn" onclick="app.adjSlider('brush-size', 5)">+</button>
                        </div>
                    </div>

                    <!-- Global Adjustments -->
                    <div class="border-t border-gray-200 pt-4">
                        <details class="group">
                            <summary
                                class="flex justify-between items-center font-bold text-xs text-gray-500 uppercase tracking-wider cursor-pointer list-none hover:text-gray-700 transition-colors py-1">
                                <span>影像調整 (全域)</span>
                                <span class="transition-transform group-open:rotate-180 duration-200"><svg
                                        class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M19 9l-7 7-7-7"></path>
                                    </svg></span>
                            </summary>
                            <div class="mt-3 space-y-4 pb-2 px-1">
                                <div>
                                    <div class="flex justify-between mb-1"><label
                                            class="text-xs font-medium text-gray-600">對比度</label><span id="contrast-val"
                                            class="text-xs text-gray-400">100%</span></div>
                                    <div class="slider-group">
                                        <button class="slider-btn" onclick="app.adjSlider('contrast', -5)">-</button>
                                        <input type="range" id="contrast" min="50" max="150" value="100"
                                            class="accent-gray-600">
                                        <button class="slider-btn" onclick="app.adjSlider('contrast', 5)">+</button>
                                    </div>
                                </div>
                                <div class="w-full h-px bg-gray-100 my-2"></div>
                                <div>
                                    <h4 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">背景風格</h4>
                                    <div class="space-y-3">
                                        <div>
                                            <div class="flex justify-between mb-1"><label
                                                    class="text-xs font-medium text-gray-600">飽和度</label><span
                                                    id="bg-sat-val" class="text-xs text-gray-400">0%</span></div>
                                            <div class="slider-group"><button class="slider-btn"
                                                    onclick="app.adjSlider('bg-sat', -5)">-</button><input type="range"
                                                    id="bg-sat" min="0" max="100" value="0"
                                                    class="accent-gray-600"><button class="slider-btn"
                                                    onclick="app.adjSlider('bg-sat', 5)">+</button></div>
                                        </div>
                                        <div>
                                            <div class="flex justify-between mb-1"><label
                                                    class="text-xs font-medium text-gray-600">壓暗</label><span
                                                    id="bg-dim-val" class="text-xs text-gray-400">0%</span></div>
                                            <div class="slider-group"><button class="slider-btn"
                                                    onclick="app.adjSlider('bg-dim', -5)">-</button><input type="range"
                                                    id="bg-dim" min="0" max="90" value="0"
                                                    class="accent-gray-600"><button class="slider-btn"
                                                    onclick="app.adjSlider('bg-dim', 5)">+</button></div>
                                        </div>
                                        <div>
                                            <div class="flex justify-between mb-1"><label
                                                    class="text-xs font-medium text-gray-600">模糊</label><span
                                                    id="bg-blur-val" class="text-xs text-gray-400">0px</span></div>
                                            <div class="slider-group"><button class="slider-btn"
                                                    onclick="app.adjSlider('bg-blur', -0.5)">-</button><input
                                                    type="range" id="bg-blur" min="0" max="10" step="0.5" value="0"
                                                    class="accent-gray-600"><button class="slider-btn"
                                                    onclick="app.adjSlider('bg-blur', 0.5)">+</button></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </details>
                    </div>
                </div>

                <!-- Panel: Text -->
                <div id="panel-text" class="space-y-5 hidden">
                    <div>
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">標記 (Tags)</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="add-start-tag"
                                class="flex items-center justify-center gap-2 bg-green-50 hover:bg-green-100 border border-green-200 text-green-700 py-2 rounded text-sm font-medium transition-all hover:shadow-sm">S
                                Start</button>
                            <button id="add-top-tag"
                                class="flex items-center justify-center gap-2 bg-red-50 hover:bg-red-100 border border-red-200 text-red-700 py-2 rounded text-sm font-medium transition-all hover:shadow-sm">T
                                Top</button>
                        </div>
                    </div>
                    <div class="border-t border-gray-200 pt-4">
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">文字 (Text)</h3>
                        <div class="flex gap-2 mb-3">
                            <input type="text" id="text-input" placeholder="輸入文字..."
                                class="flex-1 border border-gray-300 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500" />
                            <button id="add-text-btn"
                                class="bg-gray-800 hover:bg-gray-900 text-white px-3 rounded text-sm font-medium transition-colors shadow-sm">+</button>
                        </div>
                        <div id="text-controls"
                            class="space-y-4 opacity-50 pointer-events-none transition-opacity bg-gray-50 p-3 rounded-lg border border-gray-200">
                            <div>
                                <div class="flex flex-wrap gap-2" id="color-palette"></div>
                            </div>
                            <div class="flex items-center justify-between">
                                <label class="flex items-center cursor-pointer">
                                    <div class="relative"><input type="checkbox" id="text-bg-toggle" class="sr-only">
                                        <div class="w-8 h-4 bg-gray-300 rounded-full shadow-inner transition-colors"
                                            id="text-bg-track"></div>
                                        <div class="absolute left-0.5 top-0.5 w-3 h-3 bg-white rounded-full shadow transition-transform"
                                            id="text-bg-dot"></div>
                                    </div>
                                    <div class="ml-2 text-xs font-medium text-gray-700">底色</div>
                                </label>
                                <div class="flex items-center gap-2">
                                    <span class="text-xs text-gray-500">Size</span>
                                    <div class="slider-group w-24">
                                        <button class="slider-btn" onclick="app.adjSlider('text-size', -5)">-</button>
                                        <input type="range" id="text-size" min="10" max="150" value="40"
                                            class="accent-gray-700">
                                        <button class="slider-btn" onclick="app.adjSlider('text-size', 5)">+</button>
                                    </div>
                                </div>
                            </div>
                            <button id="delete-item-btn"
                                class="w-full border border-red-200 text-red-500 hover:bg-red-50 py-1.5 rounded text-xs font-medium transition-colors">刪除物件</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="processing-bar"
                class="bg-blue-600 text-white text-xs py-2 px-4 flex items-center justify-center gap-2 hidden shrink-0 shadow-inner">
                <div class="loader w-3 h-3 border-2 border-white border-t-transparent"></div><span>運算中...</span>
            </div>
        </aside>

        <!-- Canvas -->
        <section class="flex-1 bg-gray-800 relative overflow-hidden h-[60%] md:h-full checkerboard touch-none"
            id="canvas-container">
            <!-- Loupe Magnifier -->
            <div id="loupe"><canvas id="loupe-canvas"></canvas></div>

            <div id="guide-v" class="snap-line w-px h-full left-1/2 hidden transform -translate-x-1/2"></div>
            <div id="guide-h" class="snap-line h-px w-full top-1/2 hidden transform -translate-y-1/2"></div>

            <div id="canvas-transform-root"
                class="w-full h-full flex items-center justify-center origin-center transition-transform duration-75 ease-linear relative z-10">
                <div id="canvas-wrapper" class="canvas-stack shadow-2xl hidden">
                    <div id="crop-inner-backdrop" class="absolute inset-0 z-0 hidden transition-colors duration-200">
                    </div>
                    <canvas id="layer-bg" class="layer"></canvas>
                    <canvas id="layer-mask" class="layer"></canvas>
                    <canvas id="layer-ui" class="layer"></canvas>
                </div>
            </div>

            <!-- Fixed Center Crop Overlay -->
            <div id="crop-mask-container" class="crop-overlay hidden">
                <div id="crop-frame" class="crop-frame"></div>
            </div>

            <!-- Floating UI -->
            <div id="floating-toolbar"
                class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur-md shadow-xl rounded-full px-4 py-2 flex items-center gap-4 z-[60] border border-gray-200 transition-all duration-300">
                <div id="tool-switcher" class="flex bg-gray-100 rounded-full p-1">
                    <button id="tool-hand" class="tool-btn p-2 rounded-full transition-all duration-200"><svg
                            class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11">
                            </path>
                        </svg></button>
                    <button id="tool-lasso" class="tool-btn p-2 rounded-full transition-all duration-200"><svg
                            class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg></button>
                    <button id="tool-eraser" class="tool-btn p-2 rounded-full transition-all duration-200"
                        title="Eraser">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path
                                d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" />
                        </svg>
                    </button>
                </div>
                <div class="w-px h-6 bg-gray-300"></div>
                <div class="flex items-center gap-2">
                    <button id="crop-btn"
                        class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-600 font-bold transition-all"><svg
                            class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                            </path>
                        </svg></button>
                    <button id="crop-bg-color"
                        class="hidden w-6 h-6 rounded-full border border-gray-300 bg-white shadow-sm transition-all hover:scale-110"
                        title="Toggle Inner Backdrop Color"></button>
                    <span id="crop-label" class="text-[10px] text-blue-600 font-mono hidden">Orig</span>
                </div>
            </div>

            <div id="placeholder-msg"
                class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-0">
                <div
                    class="mx-auto w-16 h-16 bg-gray-700/50 text-white/50 rounded-full flex items-center justify-center mb-4 backdrop-blur-sm">
                    <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                </div>
                <h3 class="text-lg font-medium text-white/80">拖放照片至此</h3>
            </div>
        </section>
    </main>

    <script>
        // --- Web Worker ---
        const workerCode = `
            self.onmessage = function(e) {
                const { type, sel, w, h, bgData } = e.data;
                if (type === 'CALC_MASK') {
                    const result = calculateMaskInternal(sel, w, h, bgData);
                    const borderMask = sel.params.border ? getBorderInternal(result.mask, w, h, sel.params.borderThickness || 5) : null;
                    self.postMessage({ id: sel.id, mask: result.mask, borderMask, detectedColor: result.color });
                }
            };
            function colorDist(r1, g1, b1, r2, g2, b2) {
                const dr = r1 - r2, dg = g1 - g2, db = b1 - b2;
                return Math.sqrt(2 * dr * dr + 4 * dg * dg + 3 * db * db);
            }
            function isPointInPolygon(p, poly) {
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].x, yi = poly[i].y;
                    const xj = poly[j].x, yj = poly[j].y;
                    const intersect = ((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            function calculateMaskInternal(sel, w, h, bgData) {
                const mask = new Uint8Array(w * h), visited = new Uint8Array(w * h);
                const tolerance = sel.params.tolerance, palette = [], queue = [];
                let rSum = 0, gSum = 0, bSum = 0, count = 0;
                if (sel.seeds && sel.seeds.length > 0) {
                    const paths = Array.isArray(sel.seeds[0]) ? sel.seeds : [sel.seeds];
                    paths.forEach(path => {
                        if (path.length < 3) return;
                        let minX = w, maxX = 0, minY = h, maxY = 0;
                        path.forEach(p => { if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x; if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y; });
                        minX = Math.max(0, Math.floor(minX)); minY = Math.max(0, Math.floor(minY));
                        maxX = Math.min(w, Math.ceil(maxX)); maxY = Math.min(h, Math.ceil(maxY));
                        for (let y = minY; y < maxY; y++) {
                            const row = y * w;
                            for (let x = minX; x < maxX; x++) {
                                if (isPointInPolygon({ x, y }, path)) {
                                    const idx = row + x; mask[idx] = 1;
                                    if (visited[idx] === 0) {
                                        visited[idx] = 1; queue.push(x, y);
                                        const pIdx = idx * 4;
                                        rSum += bgData[pIdx]; gSum += bgData[pIdx+1]; bSum += bgData[pIdx+2]; count++;
                                        if (palette.length < 400 && (x + y) % 4 === 0) palette.push({ r: bgData[pIdx], g: bgData[pIdx+1], b: bgData[pIdx+2] });
                                    }
                                }
                            }
                        }
                    });
                }
                if (palette.length > 0) {
                    let head = 0; const dx = [0, 1, 0, -1], dy = [-1, 0, 1, 0];
                    while (head < queue.length) {
                        const x = queue[head++], y = queue[head++];
                        for (let i = 0; i < 4; i++) {
                            const nx = x + dx[i], ny = y + dy[i];
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                const nIdx = ny * w + nx;
                                if (visited[nIdx] === 0) {
                                    visited[nIdx] = 1; const pIdx = nIdx * 4;
                                    const r = bgData[pIdx], g = bgData[pIdx+1], b = bgData[pIdx+2];
                                    let match = false;
                                    for(let s=0; s<palette.length; s+=2) if (colorDist(r, g, b, palette[s].r, palette[s].g, palette[s].b) <= tolerance) { match = true; break; }
                                    if (match) { mask[nIdx] = 1; queue.push(nx, ny); rSum += r; gSum += g; bSum += b; count++; }
                                }
                            }
                        }
                    }
                }
                if (sel.params.expand > 0) expandInternal(mask, w, h, sel.params.expand);
                if (sel.params.fillHoles) fillHolesInternal(mask, w, h);
                if (sel.manualEdits) sel.manualEdits.forEach(edit => applyEditInternal(mask, w, h, edit));
                const finalMask = keepLargestInternal(mask, w, h);
                const hex = count > 0 ? '#' + [rSum/count, gSum/count, bSum/count].map(v => Math.round(v).toString(16).padStart(2, '0')).join('') : '#EC4899';
                return { mask: finalMask, color: hex };
            }
            function expandInternal(mask, w, h, rad) {
                const old = new Uint8Array(mask);
                for(let y=0; y<h; y++) {
                    const row = y * w;
                    for(let x=0; x<w; x++) {
                        if(old[row + x]) {
                            let isEdge = (x==0 || x==w-1 || y==0 || y==h-1);
                            if(!isEdge) if(!old[row+x-1] || !old[row+x+1] || !old[row-w+x] || !old[row+w+x]) isEdge = true;
                            if (isEdge) for(let ky=-rad; ky<=rad; ky++) for(let kx=-rad; kx<=rad; kx++) {
                                const ny = y+ky, nx = x+kx; if(nx>=0 && nx<w && ny>=0 && ny<h) mask[ny*w+nx] = 1;
                            }
                        }
                    }
                }
            }
            function fillHolesInternal(mask, w, h) {
                const visited = new Uint8Array(w*h), q = [];
                for(let x=0; x<w; x++) { if(!mask[x]) { q.push(x,0); visited[x]=1; } if(!mask[(h-1)*w+x]) { q.push(x,h-1); visited[(h-1)*w+x]=1; } }
                for(let y=0; y<h; y++) { if(!mask[y*w] && !visited[y*w]) { q.push(0,y); visited[y*w]=1; } if(!mask[y*w+w-1] && !visited[y*w+w-1]) { q.push(w-1,y); visited[y*w+w-1]=1; } }
                let head = 0; const dx=[1,-1,0,0], dy=[0,0,1,-1];
                while(head < q.length) {
                    const x = q[head++], y = q[head++];
                    for(let i=0; i<4; i++) {
                        const nx=x+dx[i], ny=y+dy[i];
                        if(nx>=0 && nx<w && ny>=0 && ny<h && !mask[ny*w+nx] && !visited[ny*w+nx]) { visited[ny*w+nx] = 1; q.push(nx,ny); }
                    }
                }
                for(let i=0; i<w*h; i++) if(!mask[i] && !visited[i]) mask[i] = 1;
            }
            function applyEditInternal(mask, w, h, edit) {
                const { type, points, size } = edit, rad = size / 2, r2 = rad * rad;
                points.forEach(p => {
                    const cx = Math.floor(p.x), cy = Math.floor(p.y);
                    for(let y=Math.floor(cy-rad); y<cy+rad; y++) for(let x=Math.floor(cx-rad); x<cx+rad; x++) {
                        if (x>=0 && x<w && y>=0 && y<h && (x-cx)*(x-cx) + (y-cy)*(y-cy) <= r2) mask[y*w+x] = (type === 'add' ? 1 : 0);
                    }
                });
            }
            function keepLargestInternal(mask, w, h) {
                const visited = new Uint8Array(w * h); let maxC = 0, maxL = 0, curL = 1;
                const labels = new Int32Array(w * h);
                for (let i = 0; i < w * h; i++) {
                    if (mask[i] === 1 && visited[i] === 0) {
                        let c = 0; const q = [i]; visited[i] = 1; labels[i] = curL;
                        let head = 0;
                        while(head < q.length) {
                            const idx = q[head++]; c++; const cx = idx % w, cy = Math.floor(idx / w);
                            const dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
                            for(let d=0; d<4; d++) {
                                const nx = cx + dx[d], ny = cy + dy[d];
                                if(nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                    const nIdx = ny * w + nx; if(mask[nIdx] === 1 && visited[nIdx] === 0) { visited[nIdx] = 1; labels[nIdx] = curL; q.push(nIdx); }
                                }
                            }
                        }
                        if (c > maxC) { maxC = c; maxL = curL; }
                        curL++;
                    }
                }
                const res = new Uint8Array(w*h);
                if (maxL > 0) for (let i = 0; i < w * h; i++) if (labels[i] === maxL) res[i] = 1;
                return res;
            }
            function getBorderInternal(mask, w, h, thickness) {
                const expanded = new Uint8Array(mask.length); expanded.set(mask);
                expandInternal(expanded, w, h, thickness);
                const border = new Uint8Array(mask.length);
                for(let i=0; i<mask.length; i++) if (expanded[i] && !mask[i]) border[i] = 1;
                return border;
            }
        `;

        const COLORS_LIST = ['#FFFFFF', '#000000', '#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899'];

        class StateManager {
            constructor(onHistoryChange) {
                this.history = []; this.historyIndex = -1; this.onHistoryChange = onHistoryChange;
                this.data = { filters: { contrast: 100, bgSat: 0, bgDim: 0, bgBlur: 0 }, selections: [], objects: [], crop: { index: 0, bgWhite: true }, nextSelId: 1, nextObjId: 1 };
                this.view = { scale: 1, x: 0, y: 0, tool: 'lasso', activeTab: 'route', activeSelId: null, activeObjId: null, brushSize: 20, isDragging: false, dragType: null, tempPath: [] };
            }
            pushHistory() {
                const safe = this.data.selections.map(s => { const { mask, borderMask, ...rest } = s; return rest; });
                const snapshot = JSON.stringify({ ...this.data, selections: safe });
                if (this.historyIndex < this.history.length - 1) this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(snapshot); this.historyIndex++;
                if (this.history.length > 20) { this.history.shift(); this.historyIndex--; }
                this.onHistoryChange();
            }
            undo() { if (this.historyIndex > 0) { this.historyIndex--; this.restore(this.history[this.historyIndex]); } }
            redo() { if (this.historyIndex < this.history.length - 1) { this.historyIndex++; this.restore(this.history[this.historyIndex]); } }
            restore(json) { this.data = JSON.parse(json); this.onHistoryChange(true); }
        }

        class LayerManager {
            constructor() {
                this.bgCtx = document.getElementById('layer-bg')?.getContext('2d');
                this.maskCtx = document.getElementById('layer-mask')?.getContext('2d');
                this.uiCtx = document.getElementById('layer-ui')?.getContext('2d');
                const loupeCanvas = document.getElementById('loupe-canvas');
                this.loupeCtx = loupeCanvas ? loupeCanvas.getContext('2d') : null;
                this.wrapper = document.getElementById('canvas-wrapper');
                this.width = this.height = 0; this.image = this.bgBuffer = null;
            }
            resize(w, h) {
                this.width = w; this.height = h;
                if (this.wrapper) { this.wrapper.style.width = w + 'px'; this.wrapper.style.height = h + 'px'; }
                [this.bgCtx, this.maskCtx, this.uiCtx].forEach(ctx => { if (ctx) { ctx.canvas.width = w; ctx.canvas.height = h; } });
            }
            drawBg(img, filters) {
                if (!img || !this.bgCtx) return; this.image = img;
                const ctx = this.bgCtx; ctx.clearRect(0, 0, this.width, this.height);
                ctx.filter = `contrast(${filters.contrast}%)`; ctx.drawImage(img, 0, 0); ctx.filter = 'none';
                this.bgBuffer = ctx.getImageData(0, 0, this.width, this.height).data;
            }
            drawMasks(selections, filters) {
                if (!this.bgBuffer || !this.maskCtx) return; const ctx = this.maskCtx; ctx.clearRect(0, 0, this.width, this.height);
                ctx.save(); ctx.filter = `saturate(${filters.bgSat}%) brightness(${100 - filters.bgDim}%) blur(${filters.bgBlur}px)`;
                ctx.drawImage(this.bgCtx.canvas, 0, 0); ctx.restore();
                ctx.globalCompositeOperation = 'destination-out';
                const tempC = document.createElement('canvas'); tempC.width = this.width; tempC.height = this.height;
                const tCtx = tempC.getContext('2d'); const iData = tCtx.createImageData(this.width, this.height);
                let hasMask = false;
                selections.forEach(sel => { if (sel.mask) for (let i = 0; i < sel.mask.length; i++) if (sel.mask[i]) { iData.data[i * 4 + 3] = 255; hasMask = true; } });
                if (hasMask) { tCtx.putImageData(iData, 0, 0); ctx.save(); ctx.filter = 'blur(1.5px)'; ctx.drawImage(tempC, 0, 0); ctx.restore(); }
                ctx.globalCompositeOperation = 'source-over';
                selections.forEach(sel => {
                    if (sel.params.border && sel.borderMask) {
                        const bImg = ctx.createImageData(this.width, this.height);
                        let col = { r: 236, g: 72, b: 153 }; const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(sel.params.borderColor || '#EC4899');
                        if (res) col = { r: parseInt(res[1], 16), g: parseInt(res[2], 16), b: parseInt(res[3], 16) };
                        for (let i = 0; i < sel.borderMask.length; i++) if (sel.borderMask[i]) { const p = i * 4; bImg.data[p] = col.r; bImg.data[p + 1] = col.g; bImg.data[p + 2] = col.b; bImg.data[p + 3] = 255; }
                        const bC = document.createElement('canvas'); bC.width = this.width; bC.height = this.height;
                        bC.getContext('2d').putImageData(bImg, 0, 0); ctx.drawImage(bC, 0, 0);
                    }
                });
            }
            drawUi(state) {
                if (!this.uiCtx) return;
                const ctx = this.uiCtx; ctx.clearRect(0, 0, this.width, this.height);
                if (state.view.isDragging && state.view.tempPath.length > 0) {
                    const p = state.view.tempPath; ctx.beginPath(); ctx.moveTo(p[0].x, p[0].y);
                    for (let i = 1; i < p.length; i++) ctx.lineTo(p[i].x, p[i].y);
                    if (state.view.dragType === 'lasso') { ctx.strokeStyle = 'rgba(255, 230, 0, 0.9)'; ctx.lineWidth = 2 / state.view.scale; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); }
                    else if (state.view.dragType === 'eraser') { ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = state.view.brushSize; ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.stroke(); }
                }
                state.data.objects.forEach(obj => {
                    const isS = obj.id === state.view.activeObjId && state.view.activeTab === 'text';
                    ctx.save(); ctx.translate(obj.x, obj.y);
                    if (obj.type === 'text') {
                        ctx.font = `bold ${obj.fontSize}px sans-serif`; ctx.textBaseline = 'top'; const m = ctx.measureText(obj.text);
                        if (obj.bgColor) { ctx.fillStyle = obj.bgColor; ctx.roundRect(-8, -8, m.width + 16, obj.fontSize + 12, 8); ctx.fill(); }
                        ctx.fillStyle = obj.color; ctx.fillText(obj.text, 0, 0);
                        if (isS) { ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]); ctx.strokeRect(-4, -4, m.width + 8, obj.fontSize + 8); }
                    } else {
                        const s = obj.fontSize / 60; ctx.scale(s, s); ctx.fillStyle = obj.color; ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 4;
                        ctx.save(); ctx.rotate(-0.26); ctx.fillRect(-25, -8, 50, 16); ctx.rotate(0.52); ctx.fillRect(-25, -8, 50, 16); ctx.restore();
                        ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(obj.text, 0, 0);
                        if (isS) { ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 3; ctx.setLineDash([5, 3]); ctx.strokeRect(-30, -30, 60, 60); }
                    }
                    ctx.restore();
                });
            }
            updateLoupe(pos, scale) {
                if (!this.loupeCtx) return;
                const container = document.getElementById('canvas-container');
                if (!container) return;
                const rect = container.getBoundingClientRect();
                const l = document.getElementById('loupe'), lc = document.getElementById('loupe-canvas');
                l.style.display = 'block';
                l.style.left = (pos.screenX - rect.left - 60) + 'px';
                l.style.top = (pos.screenY - rect.top - 140) + 'px';
                lc.width = lc.height = 120;
                const ctx = this.loupeCtx; ctx.clearRect(0, 0, 120, 120);
                // Composite draw
                ctx.drawImage(this.bgCtx.canvas, pos.x - 30 / scale, pos.y - 30 / scale, 60 / scale, 60 / scale, 0, 0, 120, 120);
                ctx.drawImage(this.maskCtx.canvas, pos.x - 30 / scale, pos.y - 30 / scale, 60 / scale, 60 / scale, 0, 0, 120, 120);
                ctx.drawImage(this.uiCtx.canvas, pos.x - 30 / scale, pos.y - 30 / scale, 60 / scale, 60 / scale, 0, 0, 120, 120);
                ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(60, 0); ctx.lineTo(60, 120); ctx.moveTo(0, 60); ctx.lineTo(120, 60); ctx.stroke();
            }
            hideLoupe() { const l = document.getElementById('loupe'); if (l) l.style.display = 'none'; }
        }

        class App {
            constructor() {
                this.state = new StateManager((force) => {
                    this.updateUI(force);
                    this.flags.ui = true;
                    if (force) { this.flags.bg = true; this.flags.mask = true; }
                });
                this.layers = new LayerManager();
                this.flags = { bg: false, mask: false, ui: false };
                this.els = this.cacheDOM();
                this.initWorker(); this.initListeners(); this.loop();
            }
            initWorker() {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                this.worker = new Worker(URL.createObjectURL(blob));
                this.worker.onmessage = (e) => {
                    const sel = this.state.data.selections.find(s => s.id === e.data.id);
                    if (sel) { sel.mask = e.data.mask; sel.borderMask = e.data.borderMask; sel.detectedColor = e.data.detectedColor; }
                    this.flags.mask = true; this.updateUI();
                    const pb = document.getElementById('processing-bar'); if (pb) pb.classList.add('hidden');
                };
            }
            cacheDOM() {
                const ids = ['contrast', 'bg-sat', 'bg-dim', 'bg-blur', 'tool-hand', 'tool-lasso', 'tool-eraser', 'brush-size', 'text-input', 'text-size', 'text-bg-toggle', 'color-palette', 'color-list', 'file-upload', 'download-btn', 'canvas-container', 'canvas-transform-root', 'panel-route', 'panel-text', 'tab-route', 'tab-text', 'undo-btn', 'redo-btn', 'delete-item-btn', 'crop-btn', 'crop-frame', 'crop-bg-color', 'guide-v', 'guide-h', 'crop-mask-container', 'crop-inner-backdrop', 'layer-ui'];
                const els = {}; ids.forEach(id => els[id] = document.getElementById(id)); return els;
            }
            initListeners() {
                if (this.els['file-upload']) this.els['file-upload'].addEventListener('change', e => this.loadFile(e.target.files[0]));
                if (this.els['download-btn']) this.els['download-btn'].addEventListener('click', () => this.export());
                if (this.els['contrast']) this.els['contrast'].addEventListener('input', e => { this.state.data.filters.contrast = parseInt(e.target.value); const v = document.getElementById('contrast-val'); if (v) v.innerText = e.target.value + '%'; this.flags.bg = this.flags.mask = true; });
                ['bg-sat', 'bg-dim', 'bg-blur'].forEach(id => {
                    if (this.els[id]) this.els[id].addEventListener('input', e => {
                        const k = id.replace('-s', 'S').replace('-d', 'D').replace('-b', 'B').replace('-', '');
                        this.state.data.filters[k] = parseFloat(e.target.value); const v = document.getElementById(`${id}-val`); if (v) v.innerText = e.target.value + (id.includes('blur') ? 'px' : '%'); this.flags.mask = true;
                    });
                });
                ['hand', 'lasso', 'eraser'].forEach(t => {
                    const btn = document.getElementById(`tool-${t}`);
                    if (btn) btn.addEventListener('click', () => this.setTool(t));
                });
                if (this.els['brush-size']) this.els['brush-size'].addEventListener('input', e => { this.state.view.brushSize = parseInt(e.target.value); const v = document.getElementById('brush-size-val'); if (v) v.innerText = e.target.value + 'px'; });
                if (this.els['tab-route']) this.els['tab-route'].addEventListener('click', () => this.switchTab('route'));
                if (this.els['tab-text']) this.els['tab-text'].addEventListener('click', () => this.switchTab('text'));
                const at = document.getElementById('add-text-btn'); if (at) at.addEventListener('click', () => this.addObj('text'));
                const as = document.getElementById('add-start-tag'); if (as) as.addEventListener('click', () => this.addObj('tag', 'S', '#10B981'));
                const ap = document.getElementById('add-top-tag'); if (ap) ap.addEventListener('click', () => this.addObj('tag', 'T', '#EF4444'));
                if (this.els['delete-item-btn']) this.els['delete-item-btn'].addEventListener('click', () => { if (this.state.view.activeObjId) { this.state.data.objects = this.state.data.objects.filter(o => o.id !== this.state.view.activeObjId); this.state.view.activeObjId = null; this.flags.ui = true; this.updateUI(); this.state.pushHistory(); } });
                if (this.els['text-size']) this.els['text-size'].addEventListener('input', e => { const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId); if (o) { o.fontSize = parseInt(e.target.value); this.flags.ui = true; } });
                COLORS_LIST.forEach(c => { const b = document.createElement('button'); b.className = 'color-btn w-6 h-6 rounded-full border border-gray-200 shadow-sm transition-transform'; b.style.backgroundColor = c; b.onclick = () => { const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId); if (o) { o.color = c; this.flags.ui = true; this.updateUI(); this.state.pushHistory(); } }; if (this.els['color-palette']) this.els['color-palette'].appendChild(b); });
                if (this.els['canvas-container']) {
                    this.els['canvas-container'].addEventListener('mousedown', e => this.pointerDown(e));
                    window.addEventListener('mousemove', e => this.pointerMove(e));
                    window.addEventListener('mouseup', e => this.pointerUp(e));
                    this.els['canvas-container'].addEventListener('wheel', e => { e.preventDefault(); this.state.view.scale = Math.max(0.1, Math.min(5, this.state.view.scale * (e.deltaY > 0 ? 0.9 : 1.1))); this.updateTransform(); });
                }
                if (this.els['undo-btn']) this.els['undo-btn'].addEventListener('click', () => this.state.undo());
                if (this.els['redo-btn']) this.els['redo-btn'].addEventListener('click', () => this.state.redo());
                if (this.els['crop-btn']) this.els['crop-btn'].addEventListener('click', () => this.toggleCrop());
                if (this.els['crop-bg-color']) this.els['crop-bg-color'].addEventListener('click', () => this.toggleCropBg());
            }
            getCoords(e) {
                const uiLayer = document.getElementById('layer-ui');
                if (!uiLayer) return { x: 0, y: 0, screenX: e.clientX, screenY: e.clientY };
                const r = uiLayer.getBoundingClientRect();
                return { x: (e.clientX - r.left) * (this.layers.width / r.width), y: (e.clientY - r.top) * (this.layers.height / r.height), screenX: e.clientX, screenY: e.clientY };
            }
            loadFile(file) {
                if (!file) return; const r = new FileReader();
                r.onload = e => {
                    const img = new Image(); img.onload = () => {
                        this.img = img; this.layers.resize(img.naturalWidth, img.naturalHeight); this.layers.drawBg(img, this.state.data.filters);
                        this.state.data.selections = []; this.state.data.objects = []; this.state.history = []; this.state.historyIndex = -1; this.state.pushHistory();
                        const cw = this.els['canvas-container'].clientWidth, ch = this.els['canvas-container'].clientHeight;
                        this.state.view.scale = Math.min((cw - 40) / img.naturalWidth, (ch - 40) / img.naturalHeight);
                        this.state.view.x = 0; this.state.view.y = 0;
                        this.updateTransform();
                        const wrapper = document.getElementById('canvas-wrapper'); if (wrapper) wrapper.classList.remove('hidden');
                        const msg = document.getElementById('placeholder-msg'); if (msg) msg.classList.add('hidden');
                        if (this.els['download-btn']) this.els['download-btn'].disabled = false;
                        this.fullRedraw();
                    }; img.src = e.target.result;
                }; r.readAsDataURL(file);
            }
            loop() {
                if (this.flags.bg) { this.layers.drawBg(this.img, this.state.data.filters); this.flags.bg = false; }
                if (this.flags.mask) { this.layers.drawMasks(this.state.data.selections, this.state.data.filters); this.flags.mask = false; }
                if (this.flags.ui) { this.layers.drawUi(this.state); this.flags.ui = false; }
                requestAnimationFrame(() => this.loop());
            }
            fullRedraw() { this.flags.bg = this.flags.mask = this.flags.ui = true; }
            setTool(t) {
                this.state.view.tool = t;
                ['hand', 'lasso', 'eraser'].forEach(tool => {
                    const btn = document.getElementById(`tool-${tool}`);
                    if (btn) { btn.classList.toggle('active', t === tool); btn.classList.toggle('text-white', t === tool); }
                });
                if (this.els['canvas-container']) this.els['canvas-container'].style.cursor = t === 'hand' ? 'grab' : 'crosshair';
                if (this.els['brush-controls']) this.els['brush-controls'].classList.toggle('hidden', t !== 'eraser');
                this.flags.ui = true;
            }
            switchTab(t) {
                this.state.view.activeTab = t;
                if (this.els['panel-route']) this.els['panel-route'].classList.toggle('hidden', t !== 'route');
                if (this.els['panel-text']) this.els['panel-text'].classList.toggle('hidden', t !== 'text');
                if (this.els['tab-route']) this.els['tab-route'].className = t === 'route' ? "flex-1 py-3 text-sm font-bold text-blue-600 border-b-2 border-blue-600 bg-blue-50 transition-colors" : "flex-1 py-3 text-sm font-medium text-gray-500 hover:text-gray-700 transition-colors";
                if (this.els['tab-text']) this.els['tab-text'].className = t === 'text' ? "flex-1 py-3 text-sm font-bold text-blue-600 border-b-2 border-blue-600 bg-blue-50 transition-colors" : "flex-1 py-3 text-sm font-medium text-gray-500 hover:text-gray-700 transition-colors";
                this.setTool(t === 'route' ? 'lasso' : 'hand');
                this.flags.ui = true;
            }
            addObj(type, text, color) {
                const container = document.getElementById('canvas-container');
                if (!container) return;
                const rect = container.getBoundingClientRect();
                const p = this.getCoords({ clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2 });
                this.state.data.objects.push({ id: this.state.data.nextObjId++, type, x: p.x, y: p.y, text: text || (document.getElementById('text-input')?.value || 'Text'), color: color || '#FFFFFF', fontSize: type === 'tag' ? 60 : 40 });
                const ti = document.getElementById('text-input'); if (ti) ti.value = '';
                this.state.view.activeObjId = this.state.data.nextObjId - 1;
                this.state.pushHistory();
                this.flags.ui = true;
                this.layers.drawUi(this.state);
            }
            pointerDown(e) {
                if (!this.img) return; const p = this.getCoords(e); this.state.view.isDragging = true;
                if (this.state.view.activeTab === 'text') {
                    const hit = this.state.data.objects.slice().reverse().find(o => Math.hypot(o.x - p.x, o.y - p.y) < 50);
                    if (hit) { this.state.view.activeObjId = hit.id; this.state.view.dragType = 'object'; this.dragStart = { x: p.x, y: p.y, ox: hit.x, oy: hit.y }; }
                    else { this.state.view.activeObjId = null; this.state.view.dragType = 'pan'; this.dragStart = { cx: e.clientX, cy: e.clientY, vx: this.state.view.x, vy: this.state.view.y }; }
                } else {
                    if (this.state.view.tool === 'hand') { this.state.view.dragType = 'pan'; this.dragStart = { cx: e.clientX, cy: e.clientY, vx: this.state.view.x, vy: this.state.view.y }; }
                    else { this.state.view.dragType = this.state.view.tool; this.state.view.tempPath = [p]; this.layers.updateLoupe(p, this.state.view.scale); }
                }
                this.updateUI(); this.flags.ui = true;
            }
            pointerMove(e) {
                if (!this.state.view.isDragging) return; const p = this.getCoords(e);
                if (this.state.view.dragType === 'pan') {
                    let nx = this.dragStart.vx + (e.clientX - this.dragStart.cx), ny = this.dragStart.vy + (e.clientY - this.dragStart.cy);
                    const snapD = 20; if (this.els['guide-v']) this.els['guide-v'].classList.toggle('hidden', Math.abs(nx) > snapD); if (this.els['guide-h']) this.els['guide-h'].classList.toggle('hidden', Math.abs(ny) > snapD);
                    if (Math.abs(nx) < snapD) nx = 0; if (Math.abs(ny) < snapD) ny = 0;
                    this.state.view.x = nx; this.state.view.y = ny; this.updateTransform();
                } else if (this.state.view.dragType === 'object') {
                    const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId);
                    if (o) {
                        let nx = this.dragStart.ox + (p.x - this.dragStart.x), ny = this.dragStart.oy + (p.y - this.dragStart.y);
                        const snapD = 20 / this.state.view.scale; if (this.els['guide-v']) this.els['guide-v'].classList.toggle('hidden', Math.abs(nx) > snapD); if (this.els['guide-h']) this.els['guide-h'].classList.toggle('hidden', Math.abs(ny) > snapD);
                        if (Math.abs(nx) < snapD) nx = 0; if (Math.abs(ny) < snapD) ny = 0;
                        o.x = nx; o.y = ny; this.flags.ui = true;
                    }
                } else { this.state.view.tempPath.push(p); this.flags.ui = true; this.layers.updateLoupe(p, this.state.view.scale); }
            }
            pointerUp() {
                if (!this.state.view.isDragging) return; this.state.view.isDragging = false;
                this.layers.hideLoupe(); if (this.els['guide-v']) this.els['guide-v'].classList.add('hidden'); if (this.els['guide-h']) this.els['guide-h'].classList.add('hidden');
                const type = this.state.view.dragType, path = this.state.view.tempPath;
                if (type === 'lasso' && path.length > 3) {
                    let mId = null; const w = this.layers.width;
                    for (const s of this.state.data.selections) if (s.mask) { for (const p of path) if (s.mask[Math.floor(p.y) * w + Math.floor(p.x)]) { mId = s.id; break; } if (mId) break; }
                    let sel;
                    if (mId) { sel = this.state.data.selections.find(s => s.id === mId); sel.seeds.push(path); sel.mask = sel.borderMask = null; this.state.view.activeSelId = mId; }
                    else { const id = this.state.data.nextSelId++; sel = { id, seeds: [path], params: { tolerance: 60, expand: 0, fillHoles: true, border: true, borderThickness: 5, borderColor: '#EC4899' }, manualEdits: [], mask: null, borderMask: null, detectedColor: '#EC4899' }; this.state.data.selections.push(sel); this.state.view.activeSelId = id; }
                    this.requestWorker(sel); this.state.pushHistory(); this.updateUI();
                } else if (type === 'eraser' && path.length > 0) {
                    let sel = this.state.data.selections.find(s => s.id === this.state.view.activeSelId) || this.state.data.selections[this.state.data.selections.length - 1];
                    if (sel) { sel.manualEdits.push({ type: 'sub', points: path, size: this.state.view.brushSize }); sel.mask = sel.borderMask = null; this.requestWorker(sel); this.state.pushHistory(); }
                } else if (type === 'object') this.state.pushHistory();
                this.state.view.tempPath = []; this.state.view.dragType = null; this.flags.ui = true;
            }
            adjSlider(id, v) {
                const el = document.getElementById(id);
                if (el) { el.value = parseFloat(el.value) + v; el.dispatchEvent(new Event('input')); el.dispatchEvent(new Event('change')); }
            }
            requestWorker(sel) { const pb = document.getElementById('processing-bar'); if (pb) pb.classList.remove('hidden'); this.worker.postMessage({ type: 'CALC_MASK', sel, w: this.layers.width, h: this.layers.height, bgData: this.layers.bgBuffer }); }
            updateTransform() { if (this.els['canvas-transform-root']) this.els['canvas-transform-root'].style.transform = `translate(${this.state.view.x}px, ${this.state.view.y}px) scale(${this.state.view.scale})`; }
            updateUI(force) {
                if (force) this.fullRedraw();
                if (this.els['undo-btn']) this.els['undo-btn'].disabled = this.state.historyIndex <= 0; if (this.els['redo-btn']) this.els['redo-btn'].disabled = this.state.historyIndex >= this.state.history.length - 1;
                const list = this.els['color-list']; if (!list) return; list.innerHTML = '';
                if (this.state.data.selections.length === 0) { list.innerHTML = `<div class="text-center py-8 text-gray-400 text-sm italic border-2 border-dashed border-gray-100 rounded-lg">尚未圈選</div>`; }
                else {
                    this.state.data.selections.forEach((sel, i) => {
                        const active = sel.id === this.state.view.activeSelId;
                        const div = document.createElement('div');
                        div.className = `list-item bg-white border ${active ? 'border-blue-500 shadow-md ring-1 ring-blue-100' : 'border-gray-200'} rounded-lg transition-all duration-200 overflow-hidden mb-2`;
                        div.onclick = (e) => { if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON' && !e.target.classList.contains('toggle-checkbox')) { this.state.view.activeSelId = (active ? null : sel.id); this.updateUI(); } };
                        const cols = COLORS_LIST.map(c => { const isS = (sel.params.borderColor || '#EC4899').toLowerCase() === c.toLowerCase(); return `<button class="w-5 h-5 rounded-full border border-gray-200 shadow-sm transition-transform ${isS ? 'ring-2 ring-offset-1 ring-blue-500 scale-110' : 'hover:scale-110'}" style="background-color: ${c}" onclick="app.updateSelParam(${sel.id}, 'borderColor', '${c}')"></button>`; }).join('');
                        const badgeColor = sel.detectedColor || '#EC4899';
                        const expanded = active ? `
                            <div class="p-3 bg-gray-50 border-t border-gray-100 space-y-3">
                                <div><div class="flex justify-between mb-1 text-[10px] font-bold text-gray-500 uppercase">容許度 <span class="text-blue-600">${sel.params.tolerance}</span></div><div class="slider-group"><button class="slider-btn" onclick="app.adjSlider('sel-tol-${sel.id}', -5)">-</button><input type="range" id="sel-tol-${sel.id}" min="0" max="127" value="${sel.params.tolerance}" onchange="app.updateSelParam(${sel.id}, 'tolerance', this.value)" class="h-1 bg-gray-200 rounded-lg appearance-none flex-1 accent-blue-500"><button class="slider-btn" onclick="app.adjSlider('sel-tol-${sel.id}', 5)">+</button></div></div>
                                <div><div class="flex justify-between mb-1 text-[10px] font-bold text-gray-500 uppercase">擴展 <span class="text-purple-600">${sel.params.expand}px</span></div><div class="slider-group"><button class="slider-btn" onclick="app.adjSlider('sel-exp-${sel.id}', -1)">-</button><input type="range" id="sel-exp-${sel.id}" min="0" max="20" value="${sel.params.expand}" onchange="app.updateSelParam(${sel.id}, 'expand', this.value)" class="h-1 bg-gray-200 rounded-lg appearance-none flex-1 accent-purple-500"><button class="slider-btn" onclick="app.adjSlider('sel-exp-${sel.id}', 1)">+</button></div></div>
                                <div class="flex items-center justify-between pt-2">
                                    <label class="flex items-center text-xs text-gray-700 font-medium cursor-pointer"><input type="checkbox" onchange="app.updateSelParam(${sel.id}, 'fillHoles', this.checked)" ${sel.params.fillHoles ? 'checked' : ''} class="mr-2">自動補洞</label>
                                    <label class="flex items-center text-xs text-gray-700 font-medium cursor-pointer"><div class="relative inline-block w-9 mr-2 align-middle select-none transition duration-200 ease-in"><input type="checkbox" name="toggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-2 border-gray-300 appearance-none cursor-pointer transition-all duration-200" onchange="app.updateSelParam(${sel.id}, 'border', this.checked)" ${sel.params.border ? 'checked' : ''}/><label for="toggle" class="toggle-label block overflow-hidden h-5 rounded-full bg-gray-300 cursor-pointer transition-colors duration-200"></label></div>顯示框線</label>
                                </div>
                                ${sel.params.border ? `<div class="mt-3 pt-3 border-t border-gray-100"><div class="flex items-center justify-between mb-2 text-[10px] font-bold text-gray-500 uppercase">框線粗細<div class="slider-group"><button class="slider-btn w-6 h-6 text-xs" onclick="app.adjSlider('sel-bt-inp-${sel.id}', -1)">-</button><span class="text-xs w-6 text-center font-mono text-gray-700">${sel.params.borderThickness}</span><button class="slider-btn w-6 h-6 text-xs" onclick="app.adjSlider('sel-bt-inp-${sel.id}', 1)">+</button></div><input type="range" id="sel-bt-inp-${sel.id}" min="1" max="20" value="${sel.params.borderThickness}" class="hidden" onchange="app.updateSelParam(${sel.id}, 'borderThickness', this.value)"></div><div class="flex flex-wrap gap-2 pt-1">${cols}</div></div>` : ''}
                            </div>` : '';
                        div.innerHTML = `<div class="flex items-center p-3 cursor-pointer hover:bg-gray-50 transition-colors"><div class="w-6 h-6 rounded-md flex items-center justify-center font-bold text-xs shadow-sm border border-black/10" style="background-color: ${badgeColor}; color: ${badgeColor === '#FFFFFF' ? '#000' : '#FFF'}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${i + 1}</div><div class="flex-1 ml-3 text-sm font-bold text-gray-700">岩點 #${i + 1}</div><button onclick="app.removeSel(${sel.id})" class="text-gray-400 hover:text-red-500 hover:bg-red-50 p-1.5 rounded transition-all"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div>${expanded}`;
                        list.appendChild(div);
                    });
                }
                const actO = this.state.data.objects.find(o => o.id === this.state.view.activeObjId);
                const tCtrl = document.getElementById('text-controls');
                if (tCtrl) {
                    if (actO && this.state.view.activeTab === 'text') {
                        tCtrl.classList.remove('opacity-50', 'pointer-events-none'); if (this.els['text-size']) this.els['text-size'].value = actO.fontSize;
                        const cp = document.getElementById('color-palette'); if (cp) Array.from(cp.children).forEach((b, i) => b.classList.toggle('selected', COLORS_LIST[i] === actO.color));
                    } else tCtrl.classList.add('opacity-50', 'pointer-events-none');
                }
            }
            updateSelParam(id, k, v) { const s = this.state.data.selections.find(x => x.id === id); if (s) { s.params[k] = (k === 'fillHoles' || k === 'border' || k === 'borderColor') ? v : parseInt(v); if (k === 'borderColor') { this.flags.mask = true; this.updateUI(); } else { s.mask = s.borderMask = null; this.requestWorker(s); } this.state.pushHistory(); if (k === 'border') this.updateUI(); } }
            toggleCrop() {
                let idx = this.state.data.crop.index; idx = (idx + 1) % CROPS.length; this.state.data.crop.index = idx;
                const crop = CROPS[idx], label = document.getElementById('crop-label'); if (label) { label.innerText = crop.label; label.classList.toggle('hidden', idx === 0); }
                const frame = this.els['crop-frame'], container = this.els['crop-mask-container'], backdrop = this.els['crop-inner-backdrop'];
                if (frame && container) {
                    if (idx === 0) { container.classList.add('hidden'); if (backdrop) backdrop.style.display = 'none'; document.getElementById('crop-bg-color').classList.add('hidden'); }
                    else {
                        container.classList.remove('hidden'); frame.style.display = 'block';
                        if (backdrop) { backdrop.style.display = 'block'; backdrop.style.width = this.layers.width + 'px'; backdrop.style.height = this.layers.height + 'px'; backdrop.style.backgroundColor = this.state.data.crop.bgWhite ? 'white' : 'black'; }
                        document.getElementById('crop-bg-color').classList.remove('hidden');
                        const rect = this.els['canvas-container'].getBoundingClientRect(), aspect = crop.w / crop.h;
                        let w = rect.width - 40, h = w / aspect; if (h > rect.height - 40) { h = rect.height - 40; w = h * aspect; }
                        frame.style.width = w + 'px'; frame.style.height = h + 'px';
                    }
                }
                if (idx !== 0) { this.setTool('hand'); this.switchTab('route'); }
            }
            toggleCropBg() { this.state.data.crop.bgWhite = !this.state.data.crop.bgWhite; const b = this.els['crop-inner-backdrop']; if (b) b.style.backgroundColor = this.state.data.crop.bgWhite ? 'white' : 'black'; }
            removeSel(id) { this.state.data.selections = this.state.data.selections.filter(s => s.id !== id); if (this.state.view.activeSelId === id) this.state.view.activeSelId = null; this.flags.mask = true; this.updateUI(); this.state.pushHistory(); }
            updateTransform() { if (this.els['canvas-transform-root']) this.els['canvas-transform-root'].style.transform = `translate(${this.state.view.x}px, ${this.state.view.y}px) scale(${this.state.view.scale})`; }
            export() {
                const outC = document.createElement('canvas'); outC.width = this.layers.width; outC.height = this.layers.height;
                const ctx = outC.getContext('2d'); ctx.drawImage(document.getElementById('layer-bg'), 0, 0); ctx.drawImage(document.getElementById('layer-mask'), 0, 0); ctx.drawImage(document.getElementById('layer-ui'), 0, 0);
                const a = document.createElement('a'); a.download = 'holdfocus_export.png'; a.href = outC.toDataURL(); a.click();
            }
        }
        document.addEventListener('DOMContentLoaded', () => window.app = new App());
    </script>
</body>

</html>