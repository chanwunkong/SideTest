<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>å–®å­—æ‰‹å¯«ç·´ç¿’ - æ„è±¡ä¸»å° AI ç‰ˆ</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --bg: #0b1220;
            --card: #111827;
            --text: #e5e7eb;
            --accent: #22d3ee;
            --btn: #0ea5e9;
            --danger: #ef4444;
            --success: #10b981;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: sans-serif;
            padding: 20px;
        }

        .wrap {
            max-width: 680px;
            margin: 0 auto;
        }

        .app {
            background: var(--card);
            border: 1px solid #1f2937;
            border-radius: 20px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #334155;
            padding-bottom: 10px;
        }

        textarea {
            width: 100%;
            border-radius: 14px;
            background: #0b1220;
            color: var(--accent);
            padding: 14px;
            font-size: 32px;
            font-weight: bold;
            border: 1px solid #1f2937;
            text-align: center;
            resize: none;
        }

        canvas {
            width: 100%;
            height: 45vh;
            background: #0b1220;
            border-radius: 16px;
            touch-action: none;
            margin-top: 15px;
            border: 1px solid #334155;
            cursor: crosshair;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
        }

        .chip {
            padding: 8px 15px;
            border-radius: 999px;
            background: #1f2937;
            color: #cbd5e1;
            font-size: 14px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: 0.2s;
            min-width: 60px;
            text-align: center;
        }

        .chip:hover {
            border-color: var(--accent);
            background: #2d3748;
        }

        .chip small {
            display: block;
            font-size: 10px;
            color: #fbbf24;
            text-align: center;
        }

        .pad-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            border-radius: 14px;
            padding: 15px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            font-size: 15px;
            transition: 0.2s;
        }

        button:disabled {
            background: #4b5563 !important;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .primary {
            background: var(--btn);
            color: #000;
        }

        .success-btn {
            background: var(--success);
            color: #fff;
        }

        .danger {
            background: var(--danger);
            color: #fff;
        }

        #ipa {
            color: var(--accent);
            text-align: center;
            font-size: 20px;
            margin: 10px 0;
            min-height: 1.2em;
            font-family: monospace;
        }

        .back-link {
            color: var(--accent);
            text-decoration: none;
            font-size: 14px;
        }

        .label {
            font-size: 13px;
            color: #cbd5e1;
        }

        input[type=range] {
            width: 100%;
            margin-top: 5px;
        }

        #recognitionResult {
            background: #0b1220;
            border-radius: 10px;
            padding: 10px;
            margin-top: 15px;
            border: 1px solid #1f2937;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="app">
            <div class="header">
                <a href="index.html" class="back-link">â† è¿”å›æ§åˆ¶ä¸­å¿ƒ</a>
                <span id="langDisplay" style="font-size: 12px; color: #94a3b8;">è¼‰å…¥ä¸­...</span>
            </div>

            <div id="status" style="font-size: 12px; text-align: center; margin-bottom: 5px; color: #6b7280;"></div>

            <div class="chips" id="samples"></div>

            <textarea id="text" readonly placeholder="é»æ“Šå–®å­—é–‹å§‹"></textarea>
            <div id="ipa"></div>

            <div class="field" style="margin-top: 15px;">
                <label class="label">åº•å­—å¤§å°ï¼š<span id="fontSizeVal">120</span>px</label>
                <input type="range" id="fontSize" min="40" max="240" step="10" value="120">
            </div>

            <canvas id="pad"></canvas>

            <div class="pad-actions">
                <button class="danger" id="clearBtn">ğŸ§¹ æ¸…é™¤</button>
                <button class="success-btn" id="checkBtn">ğŸ” æª¢æŸ¥æº–ç¢ºåº¦</button>
                <button class="primary" id="speakBtn">â–¶ æœ—è®€</button>
            </div>

            <div id="recognitionResult" style="text-align:center;">
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">AI è¾¨è­˜çµæœ</div>
                <div style="font-size: 20px; font-weight: bold;">
                    <span id="aiText" style="color:var(--accent)">-</span>
                    <span style="font-size: 14px; color:#94a3b8; margin-left:10px;">
                        ç›¸ä¼¼åº¦ï¼š<span id="simVal">0</span>%
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = { apiKey: "AIzaSyBqZLFskqgyiAEc127dh95rXsOPQVLSurM", authDomain: "test-5dbba.firebaseapp.com", projectId: "test-5dbba" };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        const getGlobalSettings = () => ({
            lang: localStorage.getItem('userLang') || 'en-US',
            course: localStorage.getItem('userCourse') || 'all',
            key: localStorage.getItem('gptApiKey') || ''
        });

        function updateLangDisplay() {
            const settings = getGlobalSettings();
            document.getElementById('langDisplay').textContent = `ç›®æ¨™èªè¨€ï¼š${settings.lang}`;
        }

        const canvas = document.getElementById('pad');
        const ctx = canvas.getContext('2d');
        const textEl = document.getElementById('text');
        const ipaEl = document.getElementById('ipa');
        const samplesEl = document.getElementById('samples');
        const fontSizeEl = document.getElementById('fontSize');
        const fontSizeVal = document.getElementById('fontSizeVal');
        const statusEl = document.getElementById('status');

        let userId = null;
        let isDrawing = false;
        let strokes = [];
        let customFontSize = 120;

        auth.onAuthStateChanged(user => {
            userId = user ? user.uid : null;
            statusEl.textContent = user ? `å­¸ç¿’è€…ï¼š${user.email.split('@')[0]}` : "å°šæœªç™»å…¥";
            updateLangDisplay();
            loadSwadeshCSV();
        });

        window.addEventListener('storage', () => {
            updateLangDisplay();
            renderChips();
        });

        async function loadSwadeshCSV() {
            try {
                const resp = await fetch('swadesh.csv');
                const csvText = await resp.text();
                window.allWordData = Papa.parse(csvText, { header: true }).data;
                renderChips();
            } catch (e) { console.error("CSV åŠ è¼‰éŒ¯èª¤", e); }
        }

        async function getTranslatedWord(englishWord, targetLang) {
            if (!englishWord) return "";
            if (targetLang.startsWith('en')) return englishWord;

            // ä¿®æ­£ï¼šå¿«å– ID å¿…é ˆåŒ…å«èªè¨€ï¼Œå¦å‰‡ä¸åŒèªè¨€æœƒè®€åˆ°åŒä¸€å€‹å¿«å–
            const cacheId = `trans_${targetLang}_${englishWord}`.replace(/[\/\.#$\[\]]/g, '_');
            const transRef = db.collection('translation_cache').doc(cacheId);

            try {
                const cacheDoc = await transRef.get();
                if (cacheDoc.exists) return cacheDoc.data().translatedText;

                const settings = getGlobalSettings();
                if (!settings.key) return englishWord + " (éœ€Key)";

                const prompt = `Translate the English concept "${englishWord}" into ${targetLang}. Provide ONLY the simplest dictionary form. No periods.`;
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "gpt-4o-mini", messages: [{ role: "user", content: prompt }], temperature: 0 })
                });
                const data = await resp.json();
                if (data.error) throw new Error(data.error.message);

                const translatedText = data.choices[0].message.content.trim();
                await transRef.set({ english: englishWord, translatedText, lang: targetLang });
                return translatedText;
            } catch (e) {
                console.warn("ç¿»è­¯å¤±æ•—:", e);
                return englishWord;
            }
        }

        async function renderChips() {
            if (!window.allWordData) return;
            const settings = getGlobalSettings();
            samplesEl.innerHTML = '';

            let masteryMap = {};
            if (userId) {
                try {
                    const snap = await db.collection('users').doc(userId).collection('mastery')
                        .where('lang', '==', settings.lang).get();
                    snap.forEach(doc => { masteryMap[doc.data().conceptId] = doc.data().count || 0; });
                } catch (e) { console.error("ç†Ÿç·´åº¦è¼‰å…¥å¤±æ•—", e); }
            }

            const stageFilter = settings.course;
            const filteredRows = window.allWordData.filter(row => row['en-US'] && (stageFilter === 'all' || row['Stage'] === stageFilter));

            // å„ªåŒ–ï¼šé€ä¸€ç”Ÿæˆ Chipï¼Œé¿å… API è«‹æ±‚éæ–¼é›†ä¸­å°è‡´å¡æ­»
            for (const row of filteredRows) {
                const englishWord = row['en-US'];
                const chip = document.createElement('div');
                chip.className = 'chip';
                chip.innerHTML = `<span>...</span><small style="display:block; font-size:10px; opacity:0.6;">â˜†â˜†â˜†</small>`;
                samplesEl.appendChild(chip);

                // éåŒæ­¥æ›´æ–°è©² Chip çš„å…§å®¹
                getTranslatedWord(englishWord, settings.lang).then(translated => {
                    const count = masteryMap[englishWord] || 0;
                    const stars = 'â­'.repeat(Math.min(count, 3));
                    chip.innerHTML = `${translated}<small style="display:block; font-size:10px; opacity:0.6;">${stars || 'â˜†â˜†â˜†'}</small>`;

                    chip.onclick = () => {
                        textEl.dataset.conceptId = englishWord;
                        textEl.value = translated;
                        strokes = [];
                        redraw();
                        speakAndFetchIPA(translated);
                    };
                });
            }
        }

        async function updateConceptMastery() {
            const conceptId = textEl.dataset.conceptId;
            if (!userId || !conceptId) return;
            const settings = getGlobalSettings();
            const masteryId = `${settings.lang}_${conceptId}`.replace(/[\/\.#$\[\]]/g, '_');
            const wordRef = db.collection('users').doc(userId).collection('mastery').doc(masteryId);
            await wordRef.set({
                conceptId,
                lang: settings.lang,
                count: firebase.firestore.FieldValue.increment(1),
                lastStudied: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });

            // åƒ…å±€éƒ¨æ›´æ–°è©²å–®å­—çš„æ˜Ÿæ˜Ÿï¼Œä¸é‡åˆ·æ•´é 
            renderChips();
        }

        function drawBackgroundText() {
            const text = textEl.value.trim();
            if (!text) return;
            ctx.save();
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.font = `bold ${customFontSize}px sans-serif`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            ctx.restore();
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackgroundText();
            ctx.save();
            ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            strokes.forEach(s => {
                if (s.length < 2) return;
                ctx.beginPath(); ctx.moveTo(s[0].x, s[0].y);
                for (let i = 1; i < s.length; i++) ctx.lineTo(s[i].x, s[i].y);
                ctx.stroke();
            });
            ctx.restore();
        }

        function initCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            redraw();
        }

        canvas.onpointerdown = (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            strokes.push([{ x: e.clientX - rect.left, y: e.clientY - rect.top }]);
        };
        canvas.onpointermove = (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const pos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            strokes[strokes.length - 1].push(pos);
            redraw();
        };
        canvas.onpointerup = () => { isDrawing = false; };
        fontSizeEl.oninput = (e) => { customFontSize = e.target.value; fontSizeVal.textContent = customFontSize; redraw(); };
        document.getElementById('clearBtn').onclick = () => { strokes = []; redraw(); };

        async function recognizeHandwriting() {
            if (strokes.length === 0) return alert("è«‹å…ˆå¯«å­—ï¼");
            const settings = getGlobalSettings();
            statusEl.textContent = "ğŸ” AI è¾¨è­˜ä¸­...";
            const trace = strokes.map(s => [s.map(p => Math.round(p.x)), s.map(p => Math.round(p.y))]);
            try {
                const resp = await fetch("https://www.google.com.tw/inputtools/request?ime=handwriting&app=autotags&cs=1&oe=UTF-8", {
                    method: 'POST',
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ options: "enable_pre_space", requests: [{ writing_guide: { width: canvas.width, height: canvas.height }, ink: trace, language: settings.lang }] })
                });
                const data = await resp.json();
                if (data[0] === "SUCCESS") checkSimilarity(data[1][0][1][0]);
            } catch (e) { statusEl.textContent = "è¾¨è­˜æœå‹™éŒ¯èª¤"; }
        }

        function checkSimilarity(aiText) {
            const target = textEl.value.trim().toLowerCase();
            const input = aiText.trim().toLowerCase();
            const distance = levenshtein(target, input);
            const similarity = Math.round(((Math.max(target.length, input.length) - distance) / Math.max(target.length, input.length)) * 100);
            document.getElementById('aiText').textContent = aiText;
            document.getElementById('simVal').textContent = similarity;
            if (similarity >= 80) {
                statusEl.textContent = "âœ¨ è¾¨è­˜æˆåŠŸï¼";
                updateConceptMastery();
            } else {
                statusEl.textContent = "âŒ ç›¸ä¼¼åº¦ä¸è¶³";
            }
        }

        function levenshtein(a, b) {
            const m = [];
            for (let i = 0; i <= b.length; i++) m[i] = [i];
            for (let j = 0; j <= a.length; j++) m[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    m[i][j] = b[i - 1] === a[j - 1] ? m[i - 1][j - 1] : Math.min(m[i - 1][j - 1] + 1, m[i][j - 1] + 1, m[i - 1][j] + 1);
                }
            }
            return m[b.length][a.length];
        }

        async function speakAndFetchIPA(word) {
            const settings = getGlobalSettings();
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(word); u.lang = settings.lang;
            speechSynthesis.speak(u);
            ipaEl.textContent = "ğŸ” IPA...";
            try {
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST", headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "gpt-4o-mini", messages: [{ role: "user", content: `Provide the IPA for "${word}" in ${settings.lang}. Output IPA only.` }] })
                });
                const result = await resp.json();
                ipaEl.textContent = `[ ${result.choices[0].message.content.trim()} ]`;
            } catch (e) { ipaEl.textContent = "IPA å¤±æ•—"; }
        }

        window.onload = initCanvas;
        document.getElementById('checkBtn').onclick = recognizeHandwriting;
        document.getElementById('speakBtn').onclick = () => speakAndFetchIPA(textEl.value);
    </script>
</body>

</html>