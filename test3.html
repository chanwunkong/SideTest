<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Ë™ûÂ°äÊµÅÂãïÂ†¥ v2.5 - Stage 1-8 ÂÖ®‰∏äËâ≤Áâà</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="config.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        :root {
            --overheat: #f43f5e;
            --warm: #fbbf24;
            --cold: #94a3b8;
            --pos-noun: #3b82f6;
            --pos-verb: #22c55e;
            --pos-adj: #f59e0b;
            --pos-adv: #a855f7;
            --pos-other: #94a3b8;
        }

        #initOverlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .init-card {
            width: 100%;
            max-width: 400px;
            background: var(--card);
            padding: 30px;
            border-radius: 24px;
            border: 1px solid #334155;
            text-align: center;
        }

        .init-card input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            background: #0f172a;
            border: 1px solid #334155;
            color: white;
            border-radius: 8px;
        }

        .hud-header {
            background: #0f172a;
            padding: 20px;
            border-bottom: 2px solid #334155;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .asset-rack {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .word-asset {
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid var(--cold);
            font-size: 13px;
            white-space: nowrap;
            transition: all 0.3s;
        }

        .word-asset.warm {
            border-color: var(--warm);
            color: var(--warm);
        }

        .word-asset.overheat {
            border-color: var(--overheat);
            color: var(--overheat);
            font-weight: bold;
            box-shadow: 0 0 10px rgba(244, 63, 94, 0.3);
        }

        #chatBox {
            height: 40vh;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.5;
            cursor: pointer;
        }

        .ai-msg {
            background: #1e293b;
            align-self: flex-start;
            border-bottom-left-radius: 2px;
        }

        .user-msg {
            background: #334155;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }

        .replay-hint {
            font-size: 10px;
            color: var(--accent);
            display: block;
            margin-top: 5px;
            opacity: 0.6;
        }

        .chunk {
            display: inline-block;
            margin: 0 2px;
            border-bottom: 2px solid transparent;
        }

        .chunk.noun {
            color: var(--pos-noun);
            border-bottom-color: var(--pos-noun);
        }

        .chunk.verb {
            color: var(--pos-verb);
            border-bottom-color: var(--pos-verb);
        }

        .chunk.adj {
            color: var(--pos-adj);
            border-bottom-color: var(--pos-adj);
        }

        .chunk.adv {
            color: var(--pos-adv);
            border-bottom-color: var(--pos-adv);
        }

        .chunk.other {
            color: var(--pos-other);
        }

        .dealer-tray {
            padding: 15px;
            background: #020617;
            border-top: 1px solid #1e293b;
            min-height: 100px;
        }

        .signal-option {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            text-align: left;
            background: #1e293b;
            border: 1px solid #334155;
            color: #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .input-area {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: #0f172a;
            border-top: 1px solid #1e293b;
        }

        #userInput {
            flex: 1;
            background: #1e293b;
            border: 1px solid #334155;
            color: white;
            padding: 12px;
            border-radius: 8px;
        }

        #sendBtn {
            width: 80px;
            background: var(--btn);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="initOverlay">
        <div class="init-card">
            <h2>Ë™ûÂ°äÂçîË≠∞ÂïüÂãï</h2>
            <input type="text" id="sceneInput" placeholder="Ëº∏ÂÖ•Â†¥ÊôØÔºàÂ¶ÇÔºöÈù¢Ë©¶„ÄÅÁßüÂ±ãÁ∞ΩÁ¥Ñ...Ôºâ">
            <button onclick="startProtocol(document.getElementById('sceneInput').value)"
                style="width: 100%;">ÈñãÂßãÁ∑¥Áøí</button>
            <button onclick="startProtocol(null)"
                style="width: 100%; background: #1e293b; margin-top: 10px;">Èö®Ê©üÂ†¥ÊôØ</button>
        </div>
    </div>

    <div class="hud-header">
        <div id="assetRack" class="asset-rack"></div>
    </div>

    <div id="chatBox"></div>

    <div class="dealer-tray">
        <div id="optionsContainer"></div>
    </div>

    <div class="input-area">
        <input type="text" id="userInput" placeholder="Ëº∏ÂÖ•ÊñáÂ≠ó..." autocomplete="off">
        <button id="sendBtn">ÂÇ≥ÈÄÅ</button>
    </div>

    <script>
        let currentUserId = null;
        let wordAssets = {};
        let currentScene = "";

        // Ê†∏ÂøÉÔºöStage 1-8 ÂçîË≠∞ÂÆöÁæ©
        const PROTOCOL_STAGES = {
            "Stage 1": { desc: "Survival level. Simple words, max 3 chunks.", colorRules: ["noun", "verb"] },
            "Stage 2": { desc: "Social level. Basic daily phrases.", colorRules: ["noun", "verb", "adj"] },
            "Stage 3": { desc: "CEFR A1. Basic facts, very slow pace.", colorRules: ["noun", "verb", "adj"] },
            "Stage 4": { desc: "CEFR A2. Describe environment/past.", colorRules: ["noun", "verb", "adj", "adv"] },
            "Stage 5": { desc: "CEFR B1. Negotiating problems.", colorRules: ["noun", "verb", "adj", "adv", "other"] },
            "Stage 6": { desc: "CEFR B2. Explaining complex views.", colorRules: "all" },
            "Stage 7": { desc: "CEFR C1. Professional negotiation.", colorRules: "all" },
            "Stage 8": { desc: "CEFR C2. Master level debate/nuance.", colorRules: "all" }
        };

        function getActiveSettings() {
            return {
                key: localStorage.getItem('gptApiKey'),
                lang: localStorage.getItem('userLang') || 'en-US',
                course: localStorage.getItem('userCourse') || 'Stage 1'
            };
        }

        auth.onAuthStateChanged(user => {
            currentUserId = user ? user.uid : null;
            if (user) loadAssets(); else loadDefaultAssets();
        });

        async function loadAssets() {
            const settings = getActiveSettings();
            try {
                const snapshot = await db.collection('users').doc(currentUserId)
                    .collection('mastery').where('lang', '==', settings.lang).limit(5).get();
                if (snapshot.empty) return loadDefaultAssets();
                snapshot.forEach(doc => {
                    const data = doc.data();
                    wordAssets[data.word] = { level: data.count || 0, heat: 'Cold' };
                    renderWord(data.word);
                });
            } catch (e) { loadDefaultAssets(); }
        }

        function loadDefaultAssets() {
            ["book", "need", "time"].forEach(w => {
                wordAssets[w] = { level: 0, heat: 'Cold' };
                renderWord(w);
            });
        }

        function renderWord(word) {
            const rack = document.getElementById('assetRack');
            let el = document.getElementById(`asset-${word}`);
            if (!el) {
                el = document.createElement('div');
                el.id = `asset-${word}`; el.className = 'word-asset';
                rack.appendChild(el);
            }
            const data = wordAssets[word];
            el.className = `word-asset ${data.heat.toLowerCase()}`;
            el.innerHTML = `${word.toUpperCase()} <small>Lv.${Math.floor(data.level / 3)}</small>`;
        }

        async function startProtocol(customScene) {
            const settings = getActiveSettings();
            document.getElementById('initOverlay').style.display = 'none';
            currentScene = customScene || "Daily Chat";

            // ÂàùÂßãÂåñÊôÇË¶ÅÊ±Ç AI ‰æùÁÖßÂàÜÁ¥öÁîüÊàêÈñãÂ†¥
            const prompt = `Start roleplay in ${currentScene}. Protocol: ${settings.course}. 
            Respond in CHUNKS with POS. JSON: {"s": [{"t": "Welcome", "p": "other"}]}`;

            const res = await fetchGPT(prompt);
            const data = JSON.parse(res);
            await nextTurn(data.s);
        }

        async function nextTurn(aiSpeechChunks) {
            appendColoredMessage("AI", aiSpeechChunks);
            const settings = getActiveSettings();
            const config = PROTOCOL_STAGES[settings.course] || PROTOCOL_STAGES["Stage 1"];
            const words = Object.keys(wordAssets).join(", ");

            const prompt = `Role: Smart Dealer. Stage: ${settings.course}. Scene: ${currentScene}.
            Constraint: ${config.desc}. Targets: [${words}]. 
            Task: Generate 3 signaling options (Heavy/Light/Distractor) in CHUNKS with POS tags.
            JSON: {"heavy": [{"t": "...", "p": "noun/verb/adj/adv/other"}], "light": [...], "distractor": [...]}`;

            const response = await fetchGPT(prompt);
            renderOptions(JSON.parse(response));
        }

        function renderOptions(options) {
            const container = document.getElementById('optionsContainer');
            container.innerHTML = "";
            for (let type in options) {
                const btn = document.createElement('button');
                btn.className = 'signal-option';
                options[type].forEach(chunk => {
                    const span = document.createElement('span');
                    span.className = `chunk ${chunk.p}`;
                    span.innerText = chunk.t;
                    btn.appendChild(span);
                });
                btn.onclick = () => handleInput(options[type].map(c => c.t).join(" "), type.toUpperCase());
                container.appendChild(btn);
            }
        }

        async function handleInput(text, signalType) {
            if (!text.trim()) return;
            const settings = getActiveSettings();

            // ‰ΩøÁî®ËÄÖËº∏ÂÖ•‰πüÈÄ≤Ë°åÁµÑÂ°äÂåñÊ∏≤ÊüìÔºàÊ®ôË®ªÁÇ∫ otherÔºâ
            appendColoredMessage("User", [{ "t": text, "p": "other" }]);
            updateAssets(text, signalType);

            const prompt = `Stage: ${settings.course}. Scene: ${currentScene}. User: "${text}". 
            Reply in CHUNKS with POS tags matching the stage complexity. 
            JSON: {"s": [{"t": "...", "p": "noun/verb/adj/adv/other"}]}`;

            const res = await fetchGPT(prompt);
            nextTurn(JSON.parse(res).s);
            document.getElementById('userInput').value = "";
        }

        function appendColoredMessage(role, chunks) {
            const box = document.getElementById('chatBox');
            const settings = getActiveSettings();
            const config = PROTOCOL_STAGES[settings.course] || PROTOCOL_STAGES["Stage 1"];

            const div = document.createElement('div');
            div.className = `message ${role === 'AI' ? 'ai-msg' : 'user-msg'}`;

            chunks.forEach(chunk => {
                const span = document.createElement('span');
                // ‰æùÂàÜÁ¥öÊ±∫ÂÆöÊòØÂê¶‰∏äËâ≤
                const shouldColor = (config.colorRules === "all" || config.colorRules.includes(chunk.p));
                span.className = `chunk ${shouldColor ? chunk.p : 'other'}`;
                span.innerText = chunk.t + " ";
                div.appendChild(span);
            });

            const hint = document.createElement('small');
            hint.className = 'replay-hint';
            hint.innerHTML = '<br>üîä Click to replay';
            div.appendChild(hint);

            const fullText = chunks.map(c => c.t).join(" ");
            div.onclick = () => speak(fullText);

            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
            speak(fullText);
        }

        async function fetchGPT(prompt) {
            const settings = getActiveSettings();
            if (!settings.key) return JSON.stringify({ s: [{ "t": "Key Missing", "p": "other" }], heavy: [], light: [], distractor: [] });
            const res = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${settings.key}` },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: [{ role: "system", content: "Linguistic Protocol Dealer." }, { role: "user", content: prompt }],
                    response_format: { type: "json_object" }
                })
            });
            const data = await res.json();
            return data.choices[0].message.content;
        }

        function speak(txt) {
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(txt);
            u.lang = getActiveSettings().lang;
            speechSynthesis.speak(u);
        }

        function updateAssets(text, type) {
            for (let word in wordAssets) {
                if (text.toLowerCase().includes(word.toLowerCase())) {
                    wordAssets[word].heat = (type === 'HEAVY') ? 'Overheat' : 'Warm';
                    wordAssets[word].level += (type === 'HEAVY') ? 2 : 1;
                    renderWord(word);
                }
            }
        }

        document.getElementById('sendBtn').onclick = () => handleInput(document.getElementById('userInput').value, 'USER_INPUT');
        document.getElementById('userInput').onkeypress = (e) => { if (e.key === 'Enter') handleInput(e.target.value, 'USER_INPUT'); };
    </script>
</body>

</html>