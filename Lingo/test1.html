<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>單字手寫練習</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <script src="config.js"></script>
    <link rel="stylesheet" href="style.css">

</head>

<body>
    <div class="wrap">
        <div class="app">
            <div class="header">
                <a href="index.html" class="back-link">← 返回控制中心</a>
                <span id="langDisplay" style="font-size: 12px; color: #94a3b8;">載入中...</span>
            </div>
            <div id="status" style="font-size: 12px; text-align: center; margin-bottom: 5px; color: #6b7280;"></div>
            <div class="chips" id="samples"></div>
            <textarea id="text" placeholder="點擊單字開始"></textarea>
            <div id="ipa"></div>
            <div class="field" style="margin-top: 10px;">
                <label class="label">底字大小：<span id="fontSizeVal">240</span>px</label>
                <input type="range" id="fontSize" min="60" max="300" step="10" value="240">
            </div>
            <canvas id="pad"></canvas>
            <div class="pad-actions">
                <button class="warning" id="fetchIpaBtn">📖 查音標</button>
                <button class="danger" id="clearBtn">🧹 清除</button>
                <button class="success-btn" id="checkBtn">🔍 檢查準確度</button>
                <button class="primary" id="speakBtn">▶ 朗讀</button>
            </div>
            <div id="recognitionResult"
                style="text-align:center; background: #0b1220; border-radius: 10px; padding: 10px; margin-top: 15px; border: 1px solid #1f2937;">
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">AI 辨識結果</div>
                <div style="font-size: 20px; font-weight: bold;">
                    <span id="aiText" style="color:var(--accent)">-</span>
                    <span style="font-size: 14px; color:#94a3b8; margin-left:10px;">相似度：<span
                            id="simVal">0</span>%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pad'), ctx = canvas.getContext('2d');
        const textEl = document.getElementById('text'), ipaEl = document.getElementById('ipa');
        const samplesEl = document.getElementById('samples'), fontSizeEl = document.getElementById('fontSize');
        const statusEl = document.getElementById('status');

        let currentUserId = null, isDrawing = false, strokes = [], customFontSize = 240;

        // 初始化：不論登入狀態都先載入介面
        function initPage() {
            const settings = getGlobalSettings();
            document.getElementById('langDisplay').textContent = `目標語言：${settings.lang}`;
            initCanvas();
            loadSwadeshCSV();
        }

        // 登入狀態監聽
        auth.onAuthStateChanged(user => {
            currentUserId = user ? user.uid : null;
            if (user) {
                renderChips(); // 登入後更新星星
            }
        });

        // 執行頁面初始化
        initPage();

        async function loadSwadeshCSV() {
            try {
                const resp = await fetch('swadesh.csv');
                window.allWordData = Papa.parse(await resp.text(), { header: true, skipEmptyLines: true }).data;
                renderChips();
            } catch (e) { console.error("CSV 加載錯誤", e); }
        }

        async function getTranslatedWord(englishWord, pos, targetLang) {
            if (targetLang.startsWith('en')) return { text: englishWord, reading: englishWord };
            const cacheId = `trans_${targetLang}_${englishWord}_${pos}`.replace(/[\/\.#$\[\]\s]/g, '_');
            const transRef = db.collection('translation_cache').doc(cacheId);

            try {
                const cacheDoc = await transRef.get();
                if (cacheDoc.exists && cacheDoc.data().reading) return cacheDoc.data();

                const settings = getGlobalSettings();
                if (!settings.key) return { text: englishWord, reading: englishWord };

                const prompt = `Translate "${englishWord}" (${pos}) into ${targetLang}. Return JSON format: {"text": "word to write", "reading": "phonetic reading"}.`;
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "gpt-4o-mini", messages: [{ role: "user", content: prompt }], response_format: { type: "json_object" } })
                });
                const data = await resp.json();
                const result = JSON.parse(data.choices[0].message.content);
                const finalData = { english: englishWord, pos, text: result.text, reading: result.reading, lang: targetLang };
                await transRef.set(finalData);
                return finalData;
            } catch (e) { return { text: englishWord, reading: englishWord }; }
        }

        async function renderChips() {
            if (!window.allWordData) return;
            const settings = getGlobalSettings();
            samplesEl.innerHTML = '';

            let masteryMap = {};
            if (currentUserId) {
                const snap = await db.collection('users').doc(currentUserId).collection('mastery').where('lang', '==', settings.lang).get();
                snap.forEach(doc => { masteryMap[doc.data().conceptId] = doc.data().count || 0; });
            }

            // 依照課程設定過濾單字
            const filteredData = window.allWordData.filter(row => row['en-US'] && (settings.course === 'all' || row['Stage'] === settings.course));

            filteredData.forEach(row => {
                const englishWord = row['en-US'], pos = row['POS'] || '';
                const chip = document.createElement('div');
                chip.className = 'chip';
                // 保持原有的單字卡排版：POS標籤 -> 單字 -> 星星
                chip.innerHTML = `<span class="pos-tag">${pos}</span><span class="word-txt">...</span><small class="star-text">☆☆☆</small>`;
                samplesEl.appendChild(chip);

                getTranslatedWord(englishWord, pos, settings.lang).then(data => {
                    const count = masteryMap[englishWord] || 0;
                    chip.querySelector('.word-txt').textContent = data.text;
                    chip.querySelector('.star-text').textContent = '⭐'.repeat(Math.min(count, 3)) || '☆☆☆';
                    chip.onclick = () => {
                        textEl.dataset.conceptId = englishWord;
                        textEl.dataset.reading = data.reading;
                        textEl.value = data.text;
                        strokes = []; redraw();
                        speakWord(data.reading);
                        fetchIPA(data.text, data.reading, englishWord, pos);
                    };
                });
            });
        }

        function speakWord(reading) {
            if (!reading) return;
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(reading);
            u.lang = getGlobalSettings().lang;
            u.rate = 0.8;
            speechSynthesis.speak(u);
        }

        async function fetchIPA(word, reading, english, pos) {
            const settings = getGlobalSettings();
            if (!settings.key) return;
            ipaEl.textContent = "🔍 IPA...";
            const prompt = `Provide the IPA for the word "${word}" in ${settings.lang} for the reading "${reading}". Output JSON: {"ipa": "/.../"}.`;
            try {
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "gpt-4o-mini", messages: [{ role: "user", content: prompt }], response_format: { type: "json_object" } })
                });
                const data = await resp.json();
                const result = JSON.parse(data.choices[0].message.content);
                ipaEl.textContent = result.ipa || "-";
            } catch (e) { ipaEl.textContent = "N/A"; }
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const text = textEl.value.trim();
            if (text) {
                ctx.save(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.font = `bold ${customFontSize}px sans-serif`;
                ctx.fillText(text, canvas.width / 2, canvas.height / 2); ctx.restore();
            }
            ctx.save(); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            strokes.forEach(s => {
                if (s.length < 2) return;
                ctx.beginPath(); ctx.moveTo(s[0].x, s[0].y);
                for (let i = 1; i < s.length; i++) ctx.lineTo(s[i].x, s[i].y);
                ctx.stroke();
            }); ctx.restore();
        }

        function getCanvasPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
        }

        function initCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            redraw();
        }

        let debounceTimer;
        // 監聽手動輸入事件，僅即時更新畫布底字
        textEl.oninput = () => {
            redraw(); // 更新畫布背景字

            // 清除舊資料，但保留輸入內容供稍後查詢
            delete textEl.dataset.conceptId;
            delete textEl.dataset.reading;
            ipaEl.textContent = "";
            statusEl.textContent = "";
        };

        canvas.onpointerdown = (e) => { isDrawing = true; const pos = getCanvasPos(e); strokes.push([{ x: pos.x, y: pos.y }]); };
        canvas.onpointermove = (e) => { if (!isDrawing) return; const pos = getCanvasPos(e); strokes[strokes.length - 1].push({ x: pos.x, y: pos.y }); redraw(); };
        canvas.onpointerup = () => isDrawing = false;

        fontSizeEl.oninput = (e) => { customFontSize = e.target.value; document.getElementById('fontSizeVal').textContent = customFontSize; redraw(); };
        document.getElementById('clearBtn').onclick = () => { strokes = []; redraw(); };

        async function recognizeHandwriting() {
            if (strokes.length === 0) return;
            statusEl.textContent = "🔍 AI 辨識中...";
            const trace = strokes.map(s => [s.map(p => Math.round(p.x)), s.map(p => Math.round(p.y))]);
            try {
                const resp = await fetch("https://www.google.com.tw/inputtools/request?ime=handwriting&app=autotags&cs=1&oe=UTF-8", {
                    method: 'POST', headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ options: "enable_pre_space", requests: [{ writing_guide: { width: canvas.width, height: canvas.height }, ink: trace, language: getGlobalSettings().lang }] })
                });
                const data = await resp.json();
                if (data[0] === "SUCCESS") {
                    const aiResult = data[1][0][1][0], target = textEl.value.trim();
                    const dist = levenshtein(target, aiResult.trim());
                    const sim = Math.round(((Math.max(target.length, aiResult.length) - dist) / Math.max(target.length, aiResult.length)) * 100);
                    document.getElementById('aiText').textContent = aiResult;
                    document.getElementById('simVal').textContent = sim;
                    if (sim >= 80) { statusEl.textContent = "✨ 辨識成功！"; updateConceptMastery(); }
                    else { statusEl.textContent = "❌ 相似度不足"; }
                }
            } catch (e) { statusEl.textContent = "辨識失敗"; }
        }

        function levenshtein(a, b) {
            const m = Array.from({ length: b.length + 1 }, (_, i) => [i]);
            for (let j = 0; j <= a.length; j++) m[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    m[i][j] = b[i - 1] === a[j - 1] ? m[i - 1][j - 1] : Math.min(m[i - 1][j - 1] + 1, m[i][j - 1] + 1, m[i - 1][j] + 1);
                }
            }
            return m[b.length][a.length];
        }

        async function updateConceptMastery() {
            const conceptId = textEl.dataset.conceptId;
            if (!currentUserId || !conceptId) return;
            const settings = getGlobalSettings();
            const masteryId = `${settings.lang}_${conceptId}`.replace(/[\/\.#$\[\]\s]/g, '_');
            const wordRef = db.collection('users').doc(currentUserId).collection('mastery').doc(masteryId);
            const doc = await wordRef.get();
            const newCount = (doc.exists ? (doc.data().count || 0) : 0) + 1;
            await wordRef.set({ conceptId, word: conceptId, lang: settings.lang, count: newCount, is_ready_for_chunk: newCount >= 3, lastStudied: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
            renderChips();
        }

        window.onload = initCanvas;
        window.onresize = initCanvas;
        document.getElementById('checkBtn').onclick = recognizeHandwriting;
        document.getElementById('speakBtn').onclick = () => speakWord(textEl.dataset.reading || textEl.value);

        document.getElementById('fetchIpaBtn').onclick = async () => {
            const word = textEl.value.trim();
            if (!word) {
                statusEl.textContent = "⚠️ 請先輸入單字";
                return;
            }

            // 補上讀音資訊，讓朗讀按鈕也能運作
            textEl.dataset.reading = word;

            // 呼叫原本就有的 fetchIPA 函式
            // 參數：單字, 讀音, 英文原意(手動輸入填word), 詞性(手動輸入填custom)
            await fetchIPA(word, word, word, "custom");
        };
    </script>
</body>

</html>