<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>å–®å­—æ‰‹å¯«ç·´ç¿’ - AI è¾¨è­˜ç‰ˆ</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --bg: #0b1220;
            --card: #111827;
            --text: #e5e7eb;
            --accent: #22d3ee;
            --btn: #0ea5e9;
            --danger: #ef4444;
            --success: #10b981;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: sans-serif;
            padding: 20px;
        }

        .wrap {
            max-width: 680px;
            margin: 0 auto;
        }

        .app {
            background: var(--card);
            border: 1px solid #1f2937;
            border-radius: 20px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #334155;
            padding-bottom: 10px;
        }

        textarea {
            width: 100%;
            border-radius: 14px;
            background: #0b1220;
            color: var(--accent);
            padding: 14px;
            font-size: 32px;
            font-weight: bold;
            border: 1px solid #1f2937;
            text-align: center;
            resize: none;
        }

        canvas {
            width: 100%;
            height: 45vh;
            background: #0b1220;
            border-radius: 16px;
            touch-action: none;
            margin-top: 15px;
            border: 1px solid #334155;
            cursor: crosshair;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
        }

        .chip {
            padding: 8px 15px;
            border-radius: 999px;
            background: #1f2937;
            color: #cbd5e1;
            font-size: 14px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: 0.2s;
        }

        .chip:hover {
            border-color: var(--accent);
            background: #2d3748;
        }

        .chip small {
            display: block;
            font-size: 10px;
            color: #fbbf24;
            text-align: center;
        }

        .pad-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            border-radius: 14px;
            padding: 15px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            font-size: 15px;
            transition: 0.2s;
        }

        button:disabled {
            background: #4b5563 !important;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .primary {
            background: var(--btn);
            color: #000;
        }

        .success-btn {
            background: var(--success);
            color: #fff;
        }

        .danger {
            background: var(--danger);
            color: #fff;
        }

        #ipa {
            color: var(--accent);
            text-align: center;
            font-size: 20px;
            margin: 10px 0;
            min-height: 1.2em;
            font-family: monospace;
        }

        .back-link {
            color: var(--accent);
            text-decoration: none;
            font-size: 14px;
        }

        .label {
            font-size: 13px;
            color: #cbd5e1;
        }

        input[type=range] {
            width: 100%;
            margin-top: 5px;
        }

        #recognitionResult {
            background: #0b1220;
            border-radius: 10px;
            padding: 10px;
            margin-top: 15px;
            border: 1px solid #1f2937;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="app">
            <div class="header">
                <a href="index.html" class="back-link">â† æ§åˆ¶ä¸­å¿ƒ</a>
                <div id="status" style="font-size: 12px; color: #94a3b8;">è¼‰å…¥ä¸­...</div>
            </div>

            <div class="chips" id="samples"></div>

            <textarea id="text" readonly placeholder="é»æ“Šå–®å­—é–‹å§‹"></textarea>
            <div id="ipa"></div>

            <div class="field" style="margin-top: 15px;">
                <label class="label">åº•å­—å¤§å°ï¼š<span id="fontSizeVal">120</span>px</label>
                <input type="range" id="fontSize" min="40" max="240" step="10" value="120">
            </div>

            <canvas id="pad"></canvas>

            <div class="pad-actions">
                <button class="danger" id="clearBtn">ğŸ§¹ æ¸…é™¤</button>
                <button class="success-btn" id="checkBtn">ğŸ” æª¢æŸ¥æº–ç¢ºåº¦</button>
                <button class="primary" id="speakBtn">â–¶ æœ—è®€</button>
            </div>

            <div id="recognitionResult" style="text-align:center;">
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">AI è¾¨è­˜çµæœ</div>
                <div style="font-size: 20px; font-weight: bold;">
                    <span id="aiText" style="color:var(--accent)">-</span>
                    <span style="font-size: 14px; color:#94a3b8; margin-left:10px;">
                        ç›¸ä¼¼åº¦ï¼š<span id="simVal">0</span>%
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = { apiKey: "AIzaSyBqZLFskqgyiAEc127dh95rXsOPQVLSurM", authDomain: "test-5dbba.firebaseapp.com", projectId: "test-5dbba" };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        const getGlobalSettings = () => ({
            lang: localStorage.getItem('userLang') || 'en-US',
            course: localStorage.getItem('userCourse') || 'all',
            key: localStorage.getItem('gptApiKey') || ''
        });

        const canvas = document.getElementById('pad');
        const ctx = canvas.getContext('2d');
        const textEl = document.getElementById('text');
        const ipaEl = document.getElementById('ipa');
        const samplesEl = document.getElementById('samples');
        const fontSizeEl = document.getElementById('fontSize');
        const fontSizeVal = document.getElementById('fontSizeVal');

        let userId = null;
        let isDrawing = false;
        let strokes = [];
        let customFontSize = 120;

        auth.onAuthStateChanged(user => {
            userId = user ? user.uid : null;
            document.getElementById('status').textContent = user ? `å­¸ç¿’è€…ï¼š${user.email.split('@')[0]}` : "å°šæœªç™»å…¥";
            loadSwadeshCSV();
        });

        async function loadSwadeshCSV() {
            try {
                const resp = await fetch('swadesh.csv');
                const csvText = await resp.text();
                window.allWordData = Papa.parse(csvText, { header: true }).data;
                renderChips();
            } catch (e) { console.error("CSV åŠ è¼‰éŒ¯èª¤", e); }
        }

        async function renderChips() {
            if (!window.allWordData) return;
            const settings = getGlobalSettings();
            let masteryMap = {};
            if (userId) {
                const snap = await db.collection('users').doc(userId).collection('mastery')
                    .where('lang', '==', settings.lang).get();
                snap.forEach(doc => masteryMap[doc.data().word] = doc.data().count);
            }
            samplesEl.innerHTML = '';
            const stageFilter = settings.course;
            window.allWordData.forEach((row) => {
                const word = row[settings.lang];
                if (word && (stageFilter === 'all' || row['Stage'] === stageFilter)) {
                    const chip = document.createElement('div');
                    chip.className = 'chip';
                    const count = masteryMap[word] || 0;
                    chip.innerHTML = `${word}<small>${'â­'.repeat(Math.min(count, 3)) || 'â˜†â˜†â˜†'}</small>`;
                    chip.onclick = () => {
                        textEl.value = word;
                        strokes = [];
                        redraw();
                        speakAndFetchIPA(word);
                        document.getElementById('aiText').textContent = "-";
                        document.getElementById('simVal').textContent = "0";
                    };
                    samplesEl.appendChild(chip);
                }
            });
        }

        function drawBackgroundText() {
            const text = textEl.value.trim();
            if (!text) return;
            ctx.save();
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            let fontSize = parseInt(customFontSize);
            ctx.font = `bold ${fontSize}px sans-serif`;
            while (ctx.measureText(text).width > canvas.width * 0.9 && fontSize > 20) {
                fontSize -= 5; ctx.font = `bold ${fontSize}px sans-serif`;
            }
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            ctx.restore();
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackgroundText();
            ctx.save();
            ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath(); ctx.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
                ctx.stroke();
            });
            ctx.restore();
        }

        function initCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            redraw();
        }

        canvas.onpointerdown = (e) => {
            isDrawing = true;
            const pos = { x: e.offsetX, y: e.offsetY };
            strokes.push([pos]);
            ctx.beginPath(); ctx.moveTo(pos.x, pos.y);
        };
        canvas.onpointermove = (e) => {
            if (!isDrawing) return;
            const pos = { x: e.offsetX, y: e.offsetY };
            strokes[strokes.length - 1].push(pos);
            ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 5; ctx.lineCap = 'round';
            ctx.lineTo(pos.x, pos.y); ctx.stroke();
        };
        canvas.onpointerup = () => { isDrawing = false; redraw(); };
        fontSizeEl.oninput = (e) => { customFontSize = e.target.value; fontSizeVal.textContent = customFontSize; redraw(); };
        document.getElementById('clearBtn').onclick = () => { strokes = []; redraw(); };

        // ğŸ’¡ AI è¾¨è­˜é‚è¼¯

        async function recognizeHandwriting() {
            if (strokes.length === 0) {
                alert("è«‹å…ˆåœ¨ç•«å¸ƒä¸Šå¯«å­—ï¼");
                return;
            }

            const settings = getGlobalSettings();
            document.getElementById('status').textContent = "ğŸ” AI æ­£åœ¨è¾¨è­˜ä¸­...";
            document.getElementById('checkBtn').disabled = true; // é˜²æ­¢é‡è¤‡é»æ“Š

            // 1. è½‰æ›ç­†è·¡ä¸¦ç¢ºä¿åº§æ¨™ç‚ºæ•´æ•¸
            const trace = strokes.map(stroke => [
                stroke.map(p => Math.round(p.x)),
                stroke.map(p => Math.round(p.y)),
                []
            ]);

            // 2. ä½¿ç”¨ HTTPS ç¶²å€
            const url = "https://www.google.com.tw/inputtools/request?ime=handwriting&app=autotags&cs=1&oe=UTF-8";
            const body = {
                options: "enable_pre_space",
                requests: [{
                    writing_guide: { width: canvas.width, height: canvas.height },
                    ink: trace,
                    language: settings.lang // ç¢ºä¿èªç³»èˆ‡æ§åˆ¶ä¸­å¿ƒåŒæ­¥
                }]
            };

            try {
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });

                if (!resp.ok) throw new Error(`API å›å‚³éŒ¯èª¤: ${resp.status}`);

                const data = await resp.json();

                if (data[0] === "SUCCESS" && data[1][0][1].length > 0) {
                    const aiResult = data[1][0][1][0]; // å–å¾—å€™é¸å­—
                    checkSimilarity(aiResult);
                } else {
                    document.getElementById('status').textContent = "âŒ AI ç„¡æ³•è¾¨è­˜ï¼Œè«‹å¯«æ¸…æ¥šä¸€é»";
                }
            } catch (e) {
                console.error("è¾¨è­˜è©³ç´°éŒ¯èª¤:", e);
                document.getElementById('status').textContent = "âš ï¸ ç¶²è·¯æˆ– API é€£ç·šå¤±æ•—";
                alert("è¾¨è­˜ç™¼ç”Ÿå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚");
            } finally {
                document.getElementById('checkBtn').disabled = false;
            }
        }
        function checkSimilarity(aiText) {
            const target = textEl.value.trim().toLowerCase();
            const input = aiText.trim().toLowerCase();
            const distance = levenshtein(target, input);
            const maxLen = Math.max(target.length, input.length);
            const similarity = Math.round(((maxLen - distance) / maxLen) * 100);

            document.getElementById('aiText').textContent = aiText;
            document.getElementById('simVal').textContent = similarity;

            if (similarity >= 80) {
                document.getElementById('status').textContent = "âœ¨ è¾¨è­˜æˆåŠŸï¼ç†Ÿç·´åº¦æå‡";
                updateWordMastery(target);
            } else {
                document.getElementById('status').textContent = "âŒ ç›¸ä¼¼åº¦ä¸è¶³ï¼Œè«‹é‡å¯«";
            }
        }

        function levenshtein(a, b) {
            const matrix = [];
            for (let i = 0; i <= b.length; i++) matrix[i] = [i];
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) matrix[i][j] = matrix[i - 1][j - 1];
                    else matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
                }
            }
            return matrix[b.length][a.length];
        }

        async function updateWordMastery(word) {
            if (!userId) return;
            const settings = getGlobalSettings();
            const wordId = btoa(unescape(encodeURIComponent(`${settings.lang}_${word}`))).substring(0, 50);
            const wordRef = db.collection('users').doc(userId).collection('mastery').doc(wordId);
            await wordRef.set({ word, lang: settings.lang, count: firebase.firestore.FieldValue.increment(1), lastStudied: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
            const doc = await wordRef.get();
            if (doc.data().count >= 3) await wordRef.update({ is_ready_for_chunk: true });
            renderChips();
        }

        async function speakAndFetchIPA(word) {
            const settings = getGlobalSettings();
            const u = new SpeechSynthesisUtterance(word); u.lang = settings.lang;
            speechSynthesis.cancel(); speechSynthesis.speak(u);
            ipaEl.textContent = "ğŸ” IPA æŸ¥è©¢ä¸­...";
            const cacheId = `${settings.lang}_${word}`.replace(/[\/\.#$\[\]]/g, '_');
            try {
                const cacheDoc = await db.collection('ipa_cache').doc(cacheId).get();
                if (cacheDoc.exists) { ipaEl.textContent = `[ ${cacheDoc.data().ipa} ]`; return; }
                if (!settings.key) { ipaEl.textContent = "ç„¡ API Key"; return; }
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST", headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "gpt-4o-mini", messages: [{ role: "user", content: `Provide the IPA for "${word}" in ${settings.lang}. Output IPA only.` }] })
                });
                const result = await resp.json();
                const ipaText = result.choices[0].message.content.trim();
                await db.collection('ipa_cache').doc(cacheId).set({ ipa: ipaText, lang: settings.lang });
                ipaEl.textContent = `[ ${ipaText} ]`;
            } catch (e) { ipaEl.textContent = "IPA å¤±æ•—"; }
        }

        window.onload = initCanvas; window.onresize = initCanvas;
        document.getElementById('checkBtn').onclick = recognizeHandwriting;
        document.getElementById('speakBtn').onclick = () => speakAndFetchIPA(textEl.value);
    </script>
</body>

</html>