<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>å–®å­—æ‰‹å¯«ç·´ç¿’ - è®€éŸ³åŒæ­¥å„ªåŒ–ç‰ˆ</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --bg: #0b1220;
            --card: #111827;
            --text: #e5e7eb;
            --accent: #22d3ee;
            --btn: #0ea5e9;
            --danger: #ef4444;
            --success: #10b981;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: sans-serif;
            padding: 20px;
        }

        .wrap {
            max-width: 680px;
            margin: 0 auto;
        }

        .app {
            background: var(--card);
            border: 1px solid #1f2937;
            border-radius: 20px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #334155;
            padding-bottom: 10px;
        }

        textarea {
            width: 100%;
            border-radius: 14px;
            background: #0b1220;
            color: var(--accent);
            padding: 14px;
            font-size: 32px;
            font-weight: bold;
            border: 1px solid #1f2937;
            text-align: center;
            resize: none;
        }

        canvas {
            width: 100%;
            height: 40vh;
            background: #0b1220;
            border-radius: 16px;
            touch-action: none;
            margin-top: 15px;
            border: 1px solid #334155;
            cursor: crosshair;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            max-height: 180px;
            overflow-y: auto;
            padding: 5px;
        }

        .chip {
            padding: 8px 12px;
            border-radius: 12px;
            background: #1f2937;
            color: #cbd5e1;
            font-size: 14px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: 0.2s;
            min-width: 70px;
            text-align: center;
        }

        .chip:hover {
            border-color: var(--accent);
            background: #2d3748;
        }

        .chip .pos-tag {
            font-size: 9px;
            color: var(--accent);
            text-transform: uppercase;
            opacity: 0.8;
            display: block;
        }

        .star-text {
            display: block;
            font-size: 10px;
            color: #fbbf24;
        }

        .pad-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            border-radius: 14px;
            padding: 15px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            font-size: 15px;
            transition: 0.2s;
        }

        .primary {
            background: var(--btn);
            color: #000;
        }

        .success-btn {
            background: var(--success);
            color: #fff;
        }

        .danger {
            background: var(--danger);
            color: #fff;
        }

        #ipa {
            color: var(--accent);
            text-align: center;
            font-size: 22px;
            margin: 10px 0;
            min-height: 1.2em;
        }

        .back-link {
            color: var(--accent);
            text-decoration: none;
            font-size: 14px;
        }

        .label {
            font-size: 13px;
            color: #cbd5e1;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="app">
            <div class="header">
                <a href="index.html" class="back-link">â† è¿”å›æ§åˆ¶ä¸­å¿ƒ</a>
                <span id="langDisplay" style="font-size: 12px; color: #94a3b8;">è¼‰å…¥ä¸­...</span>
            </div>
            <div id="status" style="font-size: 12px; text-align: center; margin-bottom: 5px; color: #6b7280;"></div>
            <div class="chips" id="samples"></div>
            <textarea id="text" readonly placeholder="é»æ“Šå–®å­—é–‹å§‹"></textarea>
            <div id="ipa"></div>
            <div class="field" style="margin-top: 10px;">
                <label class="label">åº•å­—å¤§å°ï¼š<span id="fontSizeVal">240</span>px</label>
                <input type="range" id="fontSize" min="60" max="300" step="10" value="240">
            </div>
            <canvas id="pad"></canvas>
            <div class="pad-actions">
                <button class="danger" id="clearBtn">ğŸ§¹ æ¸…é™¤</button>
                <button class="success-btn" id="checkBtn">ğŸ” æª¢æŸ¥æº–ç¢ºåº¦</button>
                <button class="primary" id="speakBtn">â–¶ æœ—è®€</button>
            </div>
            <div id="recognitionResult"
                style="text-align:center; background: #0b1220; border-radius: 10px; padding: 10px; margin-top: 15px; border: 1px solid #1f2937;">
                <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">AI è¾¨è­˜çµæœ</div>
                <div style="font-size: 20px; font-weight: bold;">
                    <span id="aiText" style="color:var(--accent)">-</span>
                    <span style="font-size: 14px; color:#94a3b8; margin-left:10px;">ç›¸ä¼¼åº¦ï¼š<span
                            id="simVal">0</span>%</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = { apiKey: "AIzaSyBqZLFskqgyiAEc127dh95rXsOPQVLSurM", authDomain: "test-5dbba.firebaseapp.com", projectId: "test-5dbba" };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore(), auth = firebase.auth();

        const getGlobalSettings = () => ({
            lang: localStorage.getItem('userLang') || 'en-US',
            course: localStorage.getItem('userCourse') || 'all',
            key: localStorage.getItem('gptApiKey') || ''
        });

        const canvas = document.getElementById('pad'), ctx = canvas.getContext('2d');
        const textEl = document.getElementById('text'), ipaEl = document.getElementById('ipa');
        const samplesEl = document.getElementById('samples'), fontSizeEl = document.getElementById('fontSize');
        const statusEl = document.getElementById('status');

        let userId = null, isDrawing = false, strokes = [], customFontSize = 240;

        auth.onAuthStateChanged(user => {
            userId = user ? user.uid : null;
            document.getElementById('langDisplay').textContent = `ç›®æ¨™èªè¨€ï¼š${getGlobalSettings().lang}`;
            loadSwadeshCSV();
        });

        async function loadSwadeshCSV() {
            try {
                const resp = await fetch('swadesh.csv');
                const csvText = await resp.text();
                window.allWordData = Papa.parse(csvText, { header: true, skipEmptyLines: true }).data;
                renderChips();
            } catch (e) { console.error("CSV åŠ è¼‰éŒ¯èª¤", e); }
        }

        async function getTranslatedWord(englishWord, pos, targetLang) {
            if (targetLang.startsWith('en')) return { text: englishWord, reading: englishWord };
            const cacheId = `trans_${targetLang}_${englishWord}_${pos}`.replace(/[\/\.#$\[\]\s]/g, '_');
            const transRef = db.collection('translation_cache').doc(cacheId);

            try {
                const cacheDoc = await transRef.get();
                if (cacheDoc.exists && cacheDoc.data().reading) return cacheDoc.data();

                const settings = getGlobalSettings();
                if (!settings.key) return { text: englishWord, reading: englishWord };

                // ğŸ’¡ å¼·åˆ¶ AI åŒæ™‚å›å‚³æ¼¢å­—èˆ‡è®€éŸ³ï¼ˆå‡å/æ‹¼éŸ³ï¼‰
                const prompt = `Translate "${englishWord}" (${pos}) into ${targetLang}. 
                Return JSON format: {"text": "word to write", "reading": "phonetic reading (e.g. Hiragana for Japanese)"}.`;

                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [{ role: "user", content: prompt }],
                        response_format: { type: "json_object" },
                        temperature: 0
                    })
                });
                const data = await resp.json();
                const result = JSON.parse(data.choices[0].message.content);
                const finalData = { english: englishWord, pos, text: result.text, reading: result.reading, lang: targetLang };
                await transRef.set(finalData);
                return finalData;
            } catch (e) { return { text: englishWord, reading: englishWord }; }
        }

        async function renderChips() {
            if (!window.allWordData) return;
            const settings = getGlobalSettings();
            samplesEl.innerHTML = '';
            let masteryMap = {};
            if (userId) {
                const snap = await db.collection('users').doc(userId).collection('mastery').where('lang', '==', settings.lang).get();
                snap.forEach(doc => { masteryMap[doc.data().conceptId] = doc.data().count || 0; });
            }

            window.allWordData.filter(row => row['en-US'] && (settings.course === 'all' || row['Stage'] === settings.course))
                .forEach(row => {
                    const englishWord = row['en-US'], pos = row['POS'] || '';
                    const chip = document.createElement('div');
                    chip.className = 'chip';
                    chip.innerHTML = `<span class="pos-tag">${pos}</span><span class="word-txt">...</span><small class="star-text">â˜†â˜†â˜†</small>`;
                    samplesEl.appendChild(chip);

                    getTranslatedWord(englishWord, pos, settings.lang).then(data => {
                        const count = masteryMap[englishWord] || 0;
                        chip.querySelector('.word-txt').textContent = data.text;
                        chip.querySelector('.star-text').textContent = 'â­'.repeat(Math.min(count, 3)) || 'â˜†â˜†â˜†';
                        chip.onclick = () => {
                            textEl.dataset.conceptId = englishWord;
                            textEl.dataset.reading = data.reading; // ğŸ’¡ å­˜å…¥æ­£ç¢ºè®€éŸ³ï¼ˆã‚ãŸã—ï¼‰
                            textEl.value = data.text; // é¡¯ç¤ºæ¼¢å­—ï¼ˆç§ï¼‰
                            strokes = []; redraw();

                            // ğŸ’¡ åŸ·è¡Œå‹•ä½œï¼šä¾æ“šè®€éŸ³ç™¼è²èˆ‡æŸ¥è©¢ IPA
                            speakWord(data.reading);
                            fetchIPA(data.text, data.reading, englishWord, pos);
                        };
                    });
                });
        }

        function speakWord(reading) {
            if (!reading) return;
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(reading);
            u.lang = getGlobalSettings().lang;
            u.rate = 0.8;
            speechSynthesis.speak(u);
        }

        async function fetchIPA(word, reading, english, pos) {
            const settings = getGlobalSettings();
            if (!settings.key) return;
            ipaEl.textContent = "ğŸ” IPA...";

            // ğŸ’¡ æ”¹è‰¯ Promptï¼šåŒæ™‚å‚³å…¥æ¼¢å­—èˆ‡å‡åï¼Œè¦æ±‚ä¾ç…§å‡åçµ¦ IPA
            const prompt = `You are a phonetic expert. 
            Provide the IPA for the word "${word}" in ${settings.lang}.
            CRITICAL: The specific reading/pronunciation is "${reading}" (English concept: "${english}", POS: ${pos}).
            Output only the IPA symbols in JSON: {"ipa": "/.../"}.`;

            try {
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${settings.key}`, "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [{ role: "user", content: prompt }],
                        response_format: { type: "json_object" },
                        temperature: 0
                    })
                });
                const data = await resp.json();
                const result = JSON.parse(data.choices[0].message.content);
                ipaEl.textContent = result.ipa || "-";
            } catch (e) { ipaEl.textContent = "N/A"; }
        }

        // --- ç•«å¸ƒé‚è¼¯ (Levenshtein, redraw ç­‰ä¿æŒä¸è®Š) ---
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const text = textEl.value.trim();
            if (text) {
                ctx.save(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.font = `bold ${customFontSize}px sans-serif`;
                ctx.fillText(text, canvas.width / 2, canvas.height / 2); ctx.restore();
            }
            ctx.save(); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            strokes.forEach(s => {
                if (s.length < 2) return;
                ctx.beginPath(); ctx.moveTo(s[0].x, s[0].y);
                for (let i = 1; i < s.length; i++) ctx.lineTo(s[i].x, s[i].y);
                ctx.stroke();
            }); ctx.restore();
        }

        function initCanvas() { const rect = canvas.getBoundingClientRect(); canvas.width = rect.width; canvas.height = rect.height; redraw(); }
        canvas.onpointerdown = (e) => { isDrawing = true; const rect = canvas.getBoundingClientRect(); strokes.push([{ x: e.clientX - rect.left, y: e.clientY - rect.top }]); };
        canvas.onpointermove = (e) => { if (!isDrawing) return; const rect = canvas.getBoundingClientRect(); strokes[strokes.length - 1].push({ x: e.clientX - rect.left, y: e.clientY - rect.top }); redraw(); };
        canvas.onpointerup = () => isDrawing = false;
        fontSizeEl.oninput = (e) => { customFontSize = e.target.value; document.getElementById('fontSizeVal').textContent = customFontSize; redraw(); };
        document.getElementById('clearBtn').onclick = () => { strokes = []; redraw(); };

        async function recognizeHandwriting() {
            if (strokes.length === 0) return;
            statusEl.textContent = "ğŸ” AI è¾¨è­˜ä¸­...";
            const trace = strokes.map(s => [s.map(p => Math.round(p.x)), s.map(p => Math.round(p.y))]);
            try {
                const resp = await fetch("https://www.google.com.tw/inputtools/request?ime=handwriting&app=autotags&cs=1&oe=UTF-8", {
                    method: 'POST', headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ options: "enable_pre_space", requests: [{ writing_guide: { width: canvas.width, height: canvas.height }, ink: trace, language: getGlobalSettings().lang }] })
                });
                const data = await resp.json();
                if (data[0] === "SUCCESS") {
                    const aiResult = data[1][0][1][0], target = textEl.value.trim();
                    const dist = levenshtein(target, aiResult.trim());
                    const sim = Math.round(((Math.max(target.length, aiResult.length) - dist) / Math.max(target.length, aiResult.length)) * 100);
                    document.getElementById('aiText').textContent = aiResult;
                    document.getElementById('simVal').textContent = sim;
                    if (sim >= 80) { statusEl.textContent = "âœ¨ è¾¨è­˜æˆåŠŸï¼"; updateConceptMastery(); }
                    else { statusEl.textContent = "âŒ ç›¸ä¼¼åº¦ä¸è¶³"; }
                }
            } catch (e) { statusEl.textContent = "è¾¨è­˜å¤±æ•—"; }
        }

        function levenshtein(a, b) {
            const m = Array.from({ length: b.length + 1 }, (_, i) => [i]);
            for (let j = 0; j <= a.length; j++) m[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    m[i][j] = b[i - 1] === a[j - 1] ? m[i - 1][j - 1] : Math.min(m[i - 1][j - 1] + 1, m[i][j - 1] + 1, m[i - 1][j] + 1);
                }
            }
            return m[b.length][a.length];
        }

        async function updateConceptMastery() {
            const conceptId = textEl.dataset.conceptId;
            if (!userId || !conceptId) return;
            const settings = getGlobalSettings();
            const masteryId = `${settings.lang}_${conceptId}`.replace(/[\/\.#$\[\]\s]/g, '_');
            const wordRef = db.collection('users').doc(userId).collection('mastery').doc(masteryId);
            const doc = await wordRef.get();
            const newCount = (doc.exists ? (doc.data().count || 0) : 0) + 1;
            await wordRef.set({ conceptId, word: conceptId, lang: settings.lang, count: newCount, is_ready_for_chunk: newCount >= 3, lastStudied: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
            const targetChip = document.getElementById(`chip-${conceptId.replace(/\s+/g, '_')}`);
            if (targetChip) targetChip.querySelector('.star-text').textContent = 'â­'.repeat(Math.min(newCount, 3));
        }

        window.onload = initCanvas;
        document.getElementById('checkBtn').onclick = recognizeHandwriting;
        document.getElementById('speakBtn').onclick = () => speakWord(textEl.dataset.reading || textEl.value);
    </script>
</body>

</html>