<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XC2064 物理架構與 CLB 模擬器</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: 'Consolas', 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #header {
            padding: 12px 20px;
            background-color: #161b22;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .title { font-size: 1.1rem; font-weight: bold; color: #58a6ff; }
        .toolbar { display: flex; gap: 8px; align-items: center; }
        button {
            background-color: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            border-radius: 6px;
            transition: 0.2s;
        }
        button:hover { background-color: #30363d; border-color: #8b949e; }
        button.active { background-color: #1f6feb; color: #fff; border-color: #1f6feb; }

        #main { flex: 1; display: flex; overflow: hidden; }
        #canvas-container { flex: 1; position: relative; overflow: auto; }
        canvas { display: block; cursor: crosshair; }
        
        #sidebar {
            width: 360px;
            background-color: #0d1117;
            border-left: 1px solid #30363d;
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #30363d;
        }
        .panel-title {
            font-size: 0.9rem;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        /* CLB 配置 UI */
        .clb-config-block {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }
        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        select {
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 4px;
            border-radius: 4px;
            font-family: inherit;
        }
        
        .signal-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.8rem;
        }
        .signal-box {
            background: #21262d;
            padding: 6px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }
        .val-0 { color: #8b949e; }
        .val-1 { color: #3fb950; font-weight: bold; }
    </style>
</head>
<body>

    <div id="header">
        <div class="title">XC2064 晶片級模擬器 (精確 CLB 內部資料流)</div>
        <div class="toolbar">
            <select id="grid-size" onchange="changeGridSize()" style="background: #21262d; color: #c9d1d9; border: 1px solid #30363d; padding: 4px; border-radius: 4px; margin-right: 10px;">
                <option value="4">4x4 CLB</option>
                <option value="8" selected>8x8 CLB (XC2064)</option>
                <option value="12">12x12 CLB</option>
                <option value="16">16x16 CLB</option>
            </select>
            <span id="clock-display" style="font-size: 0.85rem; color: #8b949e; margin-right: 10px;">CLOCK: LOW</span>
            <button onclick="stepClock()">手動觸發時鐘 (Tick)</button>
            <button id="auto-clock-btn" onclick="toggleAutoClock()">自動時鐘: OFF</button>
            <button onclick="resetBoard()">重置晶片</button>
        </div>
    </div>

    <div id="main">
        <div id="canvas-container">
            <canvas id="chipCanvas"></canvas>
        </div>

        <div id="sidebar">
            <div class="panel-section">
                <div class="panel-title">硬體操作說明</div>
                <div style="font-size: 0.8rem; line-height: 1.6; color: #8b949e;">
                    1. <b>點擊引腳</b>：切換周邊 IOB 狀態。<br>
                    2. <b>點擊通道交點</b>：切換 Switch Matrix 導通狀態。<br>
                    3. <b>點擊 CLB</b>：選取邏輯塊，並在下方配置其內部結構。<br>
                    (依照真實 XC2064 架構，每個 CLB 具有獨立的 F/G 邏輯產生器與多路選擇器)
                </div>
            </div>

            <div class="panel-section" id="config-panel" style="display: none;">
                <div class="panel-title">選取 CLB: <span id="selected-clb-id" style="color: #58a6ff;">--</span></div>
                
                <div class="clb-config-block">
                    <div style="color: #58a6ff; font-weight: bold; margin-bottom: 8px;">組合邏輯 (LUT)</div>
                    <div class="config-row">
                        <span>F 輸出邏輯 (依賴 A,B,C)</span>
                        <select id="cfg-f" onchange="updateCLBConfig()">
                            <option value="A_AND_B">A AND B</option>
                            <option value="A_OR_B">A OR B</option>
                            <option value="A_XOR_B">A XOR B</option>
                            <option value="NOT_A">NOT A</option>
                            <option value="PASSTHROUGH_A">Pass A</option>
                            <option value="ZERO">0</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <span>G 輸出邏輯 (依賴 A,B,C,D)</span>
                        <select id="cfg-g" onchange="updateCLBConfig()">
                            <option value="C_AND_D">C AND D</option>
                            <option value="C_OR_D">C OR D</option>
                            <option value="C_XOR_D">C XOR D</option>
                            <option value="NOT_C">NOT C</option>
                            <option value="PASSTHROUGH_C">Pass C</option>
                            <option value="ZERO">0</option>
                        </select>
                    </div>
                </div>

                <div class="clb-config-block">
                    <div style="color: #d2a8ff; font-weight: bold; margin-bottom: 8px;">內部路由 MUX (選擇器)</div>
                    <div class="config-row">
                        <span>X 輸出源</span>
                        <select id="cfg-mux-x" onchange="updateCLBConfig()">
                            <option value="F">F (純組合邏輯)</option>
                            <option value="Q">Q (D-FF 暫存輸出)</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <span>Y 輸出源</span>
                        <select id="cfg-mux-y" onchange="updateCLBConfig()">
                            <option value="G">G (純組合邏輯)</option>
                            <option value="Q">Q (D-FF 暫存輸出)</option>
                        </select>
                    </div>
                </div>

                <div class="panel-title" style="margin-top: 20px;">即時訊號觀測 (Probe)</div>
                <div class="signal-grid">
                    <div class="signal-box"><span>In A (左)</span><span id="sig-a" class="val-0">0</span></div>
                    <div class="signal-box"><span>In B (上)</span><span id="sig-b" class="val-0">0</span></div>
                    <div class="signal-box"><span>In C (右)</span><span id="sig-c" class="val-0">0</span></div>
                    <div class="signal-box"><span>In D (下)</span><span id="sig-d" class="val-0">0</span></div>
                    <div class="signal-box" style="background: #1f2428;"><span>LUT F</span><span id="sig-f" class="val-0">0</span></div>
                    <div class="signal-box" style="background: #1f2428;"><span>LUT G</span><span id="sig-g" class="val-0">0</span></div>
                    <div class="signal-box" style="background: #282433;"><span>D-FF Q</span><span id="sig-q" class="val-0">0</span></div>
                    <div></div>
                    <div class="signal-box" style="border: 1px solid #58a6ff;"><span>Out X</span><span id="sig-x" class="val-0">0</span></div>
                    <div class="signal-box" style="border: 1px solid #58a6ff;"><span>Out Y</span><span id="sig-y" class="val-0">0</span></div>
                </div>
            </div>
            
            <div id="no-select-msg" style="padding: 20px; color: #8b949e; text-align: center;">
                請點擊畫布上的 CLB 方塊以檢視其內部架構。
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('chipCanvas');
    const ctx = canvas.getContext('2d');

    // 晶片物理參數
    let GRID_SIZE = 8;
    const CLB_SIZE = 44;
    const CH_W = 24; 
    const OFFSET_X = 60;
    const OFFSET_Y = 40;

    let clbs = [];
    let h_wires = []; 
    let v_wires = []; 
    let switch_box = []; 
    let iob_in = [];
    let iob_out = [];
    
    let clockVal = 0;
    let autoClockId = null;
    let activeClb = null;

    function init() {
        window.addEventListener('resize', resize);
        canvas.addEventListener('mousedown', handleClick);
        buildGrid();
        requestAnimationFrame(renderLoop);
    }

    function buildGrid() {
        clbs = [];
        h_wires = [];
        v_wires = [];
        switch_box = [];
        iob_in = [];
        iob_out = [];
        activeClb = null;

        // 建立 CLB 陣列
        for (let r = 0; r < GRID_SIZE; r++) {
            clbs[r] = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                clbs[r][c] = {
                    id: `${String.fromCharCode(65+r)}${String.fromCharCode(65+c)}`,
                    x: OFFSET_X + c * (CLB_SIZE + CH_W),
                    y: OFFSET_Y + r * (CLB_SIZE + CH_W),
                    // 配置 SRAM
                    cfg_f: 'PASSTHROUGH_A', 
                    cfg_g: 'ZERO',
                    mux_x: 'F', // 'F' or 'Q'
                    mux_y: 'G', // 'G' or 'Q'
                    // 即時電平狀態
                    in_A: 0, in_B: 0, in_C: 0, in_D: 0,
                    val_F: 0, val_G: 0, val_Q: 0,
                    out_X: 0, out_Y: 0
                };
            }
        }

        // 初始化佈線層
        for (let r = 0; r <= GRID_SIZE; r++) {
            h_wires[r] = Array.from({length: GRID_SIZE}, () => ({ on: false, val: 0 }));
            switch_box[r] = new Array(GRID_SIZE + 1).fill(false);
        }
        for (let r = 0; r < GRID_SIZE; r++) {
            v_wires[r] = Array.from({length: GRID_SIZE + 1}, () => ({ on: false, val: 0 }));
        }

        // IOB 初始化
        for (let i = 0; i < GRID_SIZE; i++) {
            iob_in.push({ val: 0, y: OFFSET_Y + i * (CLB_SIZE + CH_W) + CLB_SIZE/2 });
            iob_out.push({ val: 0, y: OFFSET_Y + i * (CLB_SIZE + CH_W) + CLB_SIZE/2 });
        }

        document.getElementById('config-panel').style.display = 'none';
        document.getElementById('no-select-msg').style.display = 'block';
        resize();
    }

    function changeGridSize() {
        GRID_SIZE = parseInt(document.getElementById('grid-size').value, 10);
        buildGrid();
    }

    function resize() {
        if (!canvas.parentElement) return;
        const minWidth = OFFSET_X + GRID_SIZE * (CLB_SIZE + CH_W) + 100;
        const minHeight = OFFSET_Y + GRID_SIZE * (CLB_SIZE + CH_W) + 100;
        canvas.width = Math.max(canvas.parentElement.clientWidth, minWidth);
        canvas.height = Math.max(canvas.parentElement.clientHeight, minHeight);
    }

    // 時鐘與觸發器邏輯
    function stepClock() {
        clockVal = clockVal === 0 ? 1 : 0;
        document.getElementById('clock-display').innerText = `CLOCK: ${clockVal ? 'HIGH' : 'LOW'}`;
        document.getElementById('clock-display').style.color = clockVal ? '#3fb950' : '#8b949e';
        
        // 僅在上升沿觸發 D-FF
        if (clockVal === 1) {
            clbs.forEach(row => row.forEach(n => {
                // 在 XC2064 中，D-FF 的輸入可以透過 MUX 選擇，簡化版我們固定鎖存 F 的輸出
                n.val_Q = n.val_F; 
            }));
            updateSidebarUI();
        }
    }

    function toggleAutoClock() {
        if (autoClockId) {
            clearInterval(autoClockId);
            autoClockId = null;
            document.getElementById('auto-clock-btn').innerText = "自動時鐘: OFF";
            document.getElementById('auto-clock-btn').classList.remove('active');
        } else {
            autoClockId = setInterval(stepClock, 500);
            document.getElementById('auto-clock-btn').innerText = "自動時鐘: ON";
            document.getElementById('auto-clock-btn').classList.add('active');
        }
    }

    // 物理電路解算 (Relaxation Algorithm)
    function simulateCombinatorial() {
        // 重置線路電平
        for(let r=0; r<=GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) h_wires[r][c].val = 0;
            for(let c=0; c<=GRID_SIZE; c++) if(r<GRID_SIZE) v_wires[r][c].val = 0;
        }

        // 多次迭代以穩定組合邏輯
        for(let iter=0; iter<6; iter++) {
            
            // 1. 驅動輸入引腳
            for (let r = 0; r < GRID_SIZE; r++) {
                if (h_wires[r][0].on) h_wires[r][0].val |= iob_in[r].val;
            }

            // 2. 佈線網格擴散 (Switch Matrix 解析)
            for (let r = 0; r <= GRID_SIZE; r++) {
                for (let c = 0; c <= GRID_SIZE; c++) {
                    // 直通
                    if (c > 0 && c < GRID_SIZE && h_wires[r][c-1].on && h_wires[r][c].on) {
                        let v = h_wires[r][c-1].val | h_wires[r][c].val;
                        h_wires[r][c-1].val = v; h_wires[r][c].val = v;
                    }
                    if (r > 0 && r < GRID_SIZE && v_wires[r-1][c].on && v_wires[r][c].on) {
                        let v = v_wires[r-1][c].val | v_wires[r][c].val;
                        v_wires[r-1][c].val = v; v_wires[r][c].val = v;
                    }
                    // 轉向 (短接)
                    if (switch_box[r][c]) {
                        let v = 0;
                        if(c > 0 && h_wires[r][c-1].on) v |= h_wires[r][c-1].val;
                        if(c < GRID_SIZE && h_wires[r][c].on) v |= h_wires[r][c].val;
                        if(r > 0 && v_wires[r-1][c].on) v |= v_wires[r-1][c].val;
                        if(r < GRID_SIZE && v_wires[r][c].on) v |= v_wires[r][c].val;
                        
                        if(c > 0 && h_wires[r][c-1].on) h_wires[r][c-1].val = v;
                        if(c < GRID_SIZE && h_wires[r][c].on) h_wires[r][c].val = v;
                        if(r > 0 && v_wires[r-1][c].on) v_wires[r-1][c].val = v;
                        if(r < GRID_SIZE && v_wires[r][c].on) v_wires[r][c].val = v;
                    }
                }
            }

            // 3. CLB 內部邏輯解析 (依據 Image 2 架構)
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const n = clbs[r][c];
                    
                    // 讀取輸入 (A左, B上, C右, D下) - 修正了方向映射錯誤
                    n.in_A = v_wires[r][c].on ? v_wires[r][c].val : 0;         // 左 (垂直線)
                    n.in_B = h_wires[r][c].on ? h_wires[r][c].val : 0;         // 上 (水平線)
                    n.in_C = v_wires[r][c+1].on ? v_wires[r][c+1].val : 0;     // 右 (垂直線)
                    n.in_D = h_wires[r+1][c].on ? h_wires[r+1][c].val : 0;     // 下 (水平線)
                    
                    // LUT 運算
                    n.val_F = calcLut(n.cfg_f, n.in_A, n.in_B, n.in_C, n.in_D);
                    n.val_G = calcLut(n.cfg_g, n.in_A, n.in_B, n.in_C, n.in_D);

                    // 輸出 MUX 選擇
                    n.out_X = (n.mux_x === 'F') ? n.val_F : n.val_Q;
                    n.out_Y = (n.mux_y === 'G') ? n.val_G : n.val_Q;

                    // 驅動輸出至路由網格 (X 驅動右側垂直線，Y 驅動下方水平線) - 修正了輸出方向與索引
                    if (v_wires[r][c+1].on) v_wires[r][c+1].val |= n.out_X;
                    if (h_wires[r+1][c].on) h_wires[r+1][c].val |= n.out_Y;
                }
            }
        }
        
        // 寫入 IOB 輸出
        for (let r = 0; r < GRID_SIZE; r++) {
            iob_out[r].val = h_wires[r][GRID_SIZE-1].on ? h_wires[r][GRID_SIZE-1].val : 0;
        }
    }

    function calcLut(func, a, b, c, d) {
        switch(func) {
            case 'A_AND_B': return a & b;
            case 'A_OR_B': return a | b;
            case 'A_XOR_B': return a ^ b;
            case 'NOT_A': return (~a) & 1;
            case 'PASSTHROUGH_A': return a;
            case 'C_AND_D': return c & d;
            case 'C_OR_D': return c | d;
            case 'C_XOR_D': return c ^ d;
            case 'NOT_C': return (~c) & 1;
            case 'PASSTHROUGH_C': return c;
            case 'ZERO': return 0;
            default: return 0;
        }
    }

    function renderLoop() {
        simulateCombinatorial();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawRouting();
        drawCLBs();
        drawIO();
        updateSidebarUI();
        
        requestAnimationFrame(renderLoop);
    }

    function drawRouting() {
        // 畫線段
        ctx.lineWidth = 2;
        for (let r = 0; r <= GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if(!h_wires[r][c].on) continue;
                ctx.strokeStyle = h_wires[r][c].val ? '#3fb950' : '#30363d';
                ctx.beginPath();
                ctx.moveTo(OFFSET_X + c*(CLB_SIZE+CH_W) - CH_W/2, OFFSET_Y + r*(CLB_SIZE+CH_W) - CH_W/2);
                ctx.lineTo(OFFSET_X + c*(CLB_SIZE+CH_W) + CLB_SIZE + CH_W/2, OFFSET_Y + r*(CLB_SIZE+CH_W) - CH_W/2);
                ctx.stroke();
            }
        }
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c <= GRID_SIZE; c++) {
                if(!v_wires[r][c].on) continue;
                ctx.strokeStyle = v_wires[r][c].val ? '#3fb950' : '#30363d';
                ctx.beginPath();
                ctx.moveTo(OFFSET_X + c*(CLB_SIZE+CH_W) - CH_W/2, OFFSET_Y + r*(CLB_SIZE+CH_W) - CH_W/2);
                ctx.lineTo(OFFSET_X + c*(CLB_SIZE+CH_W) - CH_W/2, OFFSET_Y + r*(CLB_SIZE+CH_W) + CLB_SIZE + CH_W/2);
                ctx.stroke();
            }
        }

        // 畫 Switch Matrix 節點
        for (let r = 0; r <= GRID_SIZE; r++) {
            for (let c = 0; c <= GRID_SIZE; c++) {
                let x = OFFSET_X + c*(CLB_SIZE+CH_W) - CH_W/2;
                let y = OFFSET_Y + r*(CLB_SIZE+CH_W) - CH_W/2;
                ctx.fillStyle = switch_box[r][c] ? '#d2a8ff' : '#21262d';
                ctx.fillRect(x - 4, y - 4, 8, 8);
            }
        }
    }

    function drawCLBs() {
        clbs.forEach(row => row.forEach(n => {
            const isTarget = (n === activeClb);
            
            // 底框
            ctx.fillStyle = '#161b22';
            ctx.strokeStyle = isTarget ? '#58a6ff' : '#30363d';
            ctx.lineWidth = isTarget ? 2 : 1;
            ctx.fillRect(n.x, n.y, CLB_SIZE, CLB_SIZE);
            ctx.strokeRect(n.x, n.y, CLB_SIZE, CLB_SIZE);

            // 繪製微縮內部結構 (示意 LUT 與 MUX)
            ctx.fillStyle = '#21262d';
            ctx.fillRect(n.x + 4, n.y + 4, CLB_SIZE - 18, 14); // LUT 區
            ctx.fillStyle = '#8b949e';
            ctx.font = '8px sans-serif';
            ctx.fillText('LUT', n.x + 8, n.y + 14);

            ctx.fillStyle = n.val_Q ? '#1f4a2c' : '#21262d';
            ctx.fillRect(n.x + 4, n.y + 22, 14, 14); // D-FF 區
            ctx.fillStyle = n.val_Q ? '#3fb950' : '#8b949e';
            ctx.fillText('FF', n.x + 6, n.y + 32);
            
            // X, Y 輸出 MUX 狀態
            ctx.fillStyle = '#58a6ff';
            ctx.fillText(`X:${n.mux_x}`, n.x + CLB_SIZE - 16, n.y + 16);
            ctx.fillText(`Y:${n.mux_y}`, n.x + CLB_SIZE - 16, n.y + 32);

            // 輸出激活光暈
            if(n.out_X || n.out_Y) {
                ctx.strokeStyle = '#3fb950';
                ctx.strokeRect(n.x+1, n.y+1, CLB_SIZE-2, CLB_SIZE-2);
            }
        }));
    }

    function drawIO() {
        ctx.font = '10px sans-serif';
        iob_in.forEach((inp, i) => {
            ctx.fillStyle = inp.val ? '#3fb950' : '#21262d';
            ctx.fillRect(OFFSET_X - 44, inp.y - 10, 20, 20);
            ctx.fillStyle = '#8b949e';
            ctx.fillText(`IN${i}`, OFFSET_X - 70, inp.y + 4);
        });
        iob_out.forEach((out, i) => {
            ctx.fillStyle = out.val ? '#3fb950' : '#21262d';
            ctx.beginPath(); ctx.arc(OFFSET_X + GRID_SIZE*(CLB_SIZE+CH_W) - CH_W + 20, out.y, 10, 0, Math.PI*2); ctx.fill();
        });
    }

    // 介面與互動
    function handleClick(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;

        // IOB Input Toggle
        if (mx > OFFSET_X - 50 && mx < OFFSET_X - 20) {
            iob_in.forEach(inp => { if (Math.abs(my - inp.y) < 12) inp.val = inp.val ? 0 : 1; });
            return;
        }

        // CLB Selection
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const n = clbs[r][c];
                if (mx > n.x && mx < n.x + CLB_SIZE && my > n.y && my < n.y + CLB_SIZE) {
                    activeClb = n;
                    openSidebarForCLB();
                    return;
                }
            }
        }

        // Switch Matrix Toggle
        for (let r = 0; r <= GRID_SIZE; r++) {
            for (let c = 0; c <= GRID_SIZE; c++) {
                let x = OFFSET_X + c*(CLB_SIZE+CH_W) - CH_W/2;
                let y = OFFSET_Y + r*(CLB_SIZE+CH_W) - CH_W/2;
                if (Math.abs(mx - x) < 8 && Math.abs(my - y) < 8) {
                    switch_box[r][c] = !switch_box[r][c];
                    return;
                }
            }
        }

        // Wire Segment Toggle
        for (let r = 0; r <= GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                let x = OFFSET_X + c*(CLB_SIZE+CH_W) + CLB_SIZE/2;
                let y = OFFSET_Y + r*(CLB_SIZE+CH_W) - CH_W/2;
                if (Math.abs(mx - x) < CLB_SIZE/2 && Math.abs(my - y) < 8) h_wires[r][c].on = !h_wires[r][c].on;
            }
        }
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c <= GRID_SIZE; c++) {
                let x = OFFSET_X + c*(CLB_SIZE+CH_W) - CH_W/2;
                let y = OFFSET_Y + r*(CLB_SIZE+CH_W) + CLB_SIZE/2;
                if (Math.abs(mx - x) < 8 && Math.abs(my - y) < CLB_SIZE/2) v_wires[r][c].on = !v_wires[r][c].on;
            }
        }
    }

    function openSidebarForCLB() {
        if (!activeClb) return;
        document.getElementById('no-select-msg').style.display = 'none';
        document.getElementById('config-panel').style.display = 'block';
        document.getElementById('selected-clb-id').innerText = activeClb.id;
        
        document.getElementById('cfg-f').value = activeClb.cfg_f;
        document.getElementById('cfg-g').value = activeClb.cfg_g;
        document.getElementById('cfg-mux-x').value = activeClb.mux_x;
        document.getElementById('cfg-mux-y').value = activeClb.mux_y;
        
        updateSidebarUI();
    }

    function updateCLBConfig() {
        if (!activeClb) return;
        activeClb.cfg_f = document.getElementById('cfg-f').value;
        activeClb.cfg_g = document.getElementById('cfg-g').value;
        activeClb.mux_x = document.getElementById('cfg-mux-x').value;
        activeClb.mux_y = document.getElementById('cfg-mux-y').value;
    }

    function updateSidebarUI() {
        if (!activeClb) return;
        const setVal = (id, val) => {
            const el = document.getElementById(id);
            el.innerText = val;
            el.className = val ? 'val-1' : 'val-0';
        };
        setVal('sig-a', activeClb.in_A);
        setVal('sig-b', activeClb.in_B);
        setVal('sig-c', activeClb.in_C);
        setVal('sig-d', activeClb.in_D);
        setVal('sig-f', activeClb.val_F);
        setVal('sig-g', activeClb.val_G);
        setVal('sig-q', activeClb.val_Q);
        setVal('sig-x', activeClb.out_X);
        setVal('sig-y', activeClb.out_Y);
    }

    function resetBoard() {
        buildGrid();
    }

    init();
</script>
</body>
</html>