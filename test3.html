<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>èªå¡Šæµå‹•å ´ v2.6 - é¡è‰²åŒæ­¥ç‰ˆ</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="config.js"></script>
    <link rel="stylesheet" href="style.css">

</head>

<body>
    <div id="initOverlay">
        <div class="init-card">
            <h2>èªå¡Šå”è­°å•Ÿå‹•</h2>
            <input type="text" id="sceneInput" placeholder="è¼¸å…¥å°è©±å ´æ™¯ï¼ˆå¦‚ï¼šå’–å•¡å»³ã€é¢è©¦ï¼‰">
            <button onclick="startProtocol(document.getElementById('sceneInput').value)"
                style="width: 100%;">é–‹å§‹å°è©±</button>
            <button onclick="startProtocol(null)"
                style="width: 100%; background: #1e293b; margin-top: 10px;">éš¨æ©Ÿå ´æ™¯</button>
        </div>
    </div>

    <div class="hud-header">
        <div id="assetRack" class="asset-rack"></div>
    </div>

    <div id="chatBox"></div>

    <div class="dealer-tray">
        <div id="optionsContainer"></div>
    </div>

    <div class="input-area">
        <input type="text" id="userInput" placeholder="è¼¸å…¥å›æ‡‰æˆ–ç”¨èªéŸ³è¼¸å…¥..." autocomplete="off">
        <button id="sendBtn">å‚³é€</button>
    </div>

    <script>
        let currentUserId = null;
        let wordAssets = {};
        let currentScene = "";

        // åŒæ­¥è‡ª test2 çš„åˆ†ç´šå®šç¾©ï¼Œä¿®æ­£ Stage 1 ç‚º Swadesh Core 40
        const PROTOCOL_STAGES = {
            "Stage 1": { desc: "Survival level. Use ONLY Core 40 words (Pronouns, Nouns, Verbs, Numbers). Max 3 chunks per response.", colors: ["noun", "verb"] },
            "Stage 2": { desc: "Social level. Basic daily phrases with adjectives.", colors: ["noun", "verb", "adj"] },
            "Stage 3": { desc: "CEFR A1. Basic functional chunks.", colors: ["noun", "verb", "adj"] },
            "Stage 4": { desc: "CEFR A2. Describe environment with adverbs.", colors: ["noun", "verb", "adj", "adv"] },
            "Stage 5": { desc: "CEFR B1. Negotiating problems.", colors: "all" },
            "Stage 6": { desc: "CEFR B2. Sophisticated language.", colors: "all" },
            "Stage 7": { desc: "CEFR C1. Idiomatic chunks.", colors: "all" },
            "Stage 8": { desc: "CEFR C2. Master level nuance.", colors: "all" }
        };

        function getActiveSettings() {
            return {
                key: localStorage.getItem('gptApiKey'),
                lang: localStorage.getItem('userLang') || 'en-US',
                course: localStorage.getItem('userCourse') || 'Stage 1'
            };
        }

        auth.onAuthStateChanged(user => {
            currentUserId = user ? user.uid : null;
            if (user) loadAssets(); else loadDefaultAssets();
        });

        async function loadAssets() {
            const settings = getActiveSettings();
            try {
                const snapshot = await db.collection('users').doc(currentUserId)
                    .collection('mastery').where('lang', '==', settings.lang).limit(5).get();
                if (snapshot.empty) return loadDefaultAssets();
                snapshot.forEach(doc => {
                    const data = doc.data();
                    wordAssets[data.word] = { level: data.count || 0, heat: 'Cold' };
                    renderWord(data.word);
                });
            } catch (e) { loadDefaultAssets(); }
        }

        function loadDefaultAssets() {
            // é è¨­ç”Ÿå­˜èªå¡Š
            ["I", "want", "eat", "this"].forEach(w => {
                wordAssets[w] = { level: 0, heat: 'Cold' };
                renderWord(w);
            });
        }

        function renderWord(word) {
            const rack = document.getElementById('assetRack');
            let el = document.getElementById(`asset-${word}`);
            if (!el) {
                el = document.createElement('div');
                el.id = `asset-${word}`; el.className = 'word-asset';
                rack.appendChild(el);
            }
            const data = wordAssets[word];
            el.className = `word-asset ${data.heat.toLowerCase()}`;
            el.innerHTML = `${word.toUpperCase()} <small>Lv.${Math.floor(data.level / 3)}</small>`;
        }

        async function startProtocol(customScene) {
            const settings = getActiveSettings();
            document.getElementById('initOverlay').style.display = 'none';
            currentScene = customScene || "Daily Chat";

            // åˆæ¬¡ç”Ÿæˆä¹Ÿå¿…é ˆå¸¶æœ‰çµ„å¡Šæ¨™è¨»
            const prompt = `Start roleplay in ${currentScene}. Level: ${settings.course}. 
            Return AI opening as CHUNKS. JSON: {"s": [{"t": "Welcome", "p": "other"}]}`;

            const res = await fetchGPT(prompt);
            const data = JSON.parse(res);
            await nextTurn(data.s);
        }

        async function nextTurn(aiSpeechChunks) {
            appendColoredMessage("AI", aiSpeechChunks);
            const settings = getActiveSettings();
            const config = PROTOCOL_STAGES[settings.course];
            const words = Object.keys(wordAssets).join(", ");

            const prompt = `Scene: ${currentScene}. Targets: [${words}]. 
            Level: ${settings.course}. Constraint: ${config.desc}
            Generate 3 signaling options in CHUNKS with POS tags (noun, verb, adj, adv, other).
            JSON: {"heavy": [{"t": "...", "p": "pos"}], "light": [...], "distractor": [...]}`;

            const response = await fetchGPT(prompt);
            renderOptions(JSON.parse(response));
        }

        function renderOptions(options) {
            const container = document.getElementById('optionsContainer');
            container.innerHTML = "";
            for (let type in options) {
                const btn = document.createElement('button');
                btn.className = 'signal-option';
                options[type].forEach(chunk => {
                    const span = document.createElement('span');
                    span.className = `chunk ${chunk.p}`;
                    span.innerText = chunk.t;
                    btn.appendChild(span);
                });
                btn.onclick = () => handleInput(options[type].map(c => c.t).join(" "), type.toUpperCase());
                container.appendChild(btn);
            }
        }

        async function handleInput(text, signalType) {
            if (!text.trim()) return;
            // ä½¿ç”¨è€…è¼¸å…¥çµ„å¡ŠåŒ–é¡¯ç¤º
            appendColoredMessage("User", [{ "t": text, "p": "other" }]);
            updateAssets(text, signalType);

            const settings = getActiveSettings();
            const prompt = `Scene: ${currentScene}. User: "${text}". 
            Reply in CHUNKS at ${settings.course} level. JSON: {"s": [{"t": "...", "p": "pos"}]}`;

            const res = await fetchGPT(prompt);
            nextTurn(JSON.parse(res).s);
            document.getElementById('userInput').value = "";
        }

        function appendColoredMessage(role, chunks) {
            const box = document.getElementById('chatBox');
            const settings = getActiveSettings();
            const config = PROTOCOL_STAGES[settings.course];
            const div = document.createElement('div');
            div.className = `message ${role === 'AI' ? 'ai-msg' : 'user-msg'}`;

            chunks.forEach(chunk => {
                const span = document.createElement('span');
                // ä¾ç­‰ç´šæ±ºå®šæ˜¯å¦ä¸Šè‰²
                const shouldColor = (config.colors === "all" || config.colors.includes(chunk.p));
                span.className = `chunk ${shouldColor ? chunk.p : 'other'}`;
                span.innerText = chunk.t + " ";
                div.appendChild(span);
            });

            const hint = document.createElement('small');
            hint.className = 'replay-hint';
            hint.innerHTML = '<br>ğŸ”Š Click to replay';
            div.appendChild(hint);

            const fullText = chunks.map(c => c.t).join(" ");
            div.onclick = () => speak(fullText);

            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
            speak(fullText);
        }

        async function fetchGPT(prompt) {
            const settings = getActiveSettings();
            if (!settings.key) return JSON.stringify({ s: [{ "t": "Key Missing", "p": "other" }], heavy: [], light: [], distractor: [] });
            const res = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${settings.key}` },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: [{ role: "user", content: prompt }],
                    response_format: { type: "json_object" }
                })
            });
            const data = await res.json();
            return data.choices[0].message.content;
        }

        function speak(txt) {
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(txt);
            u.lang = getActiveSettings().lang;
            speechSynthesis.speak(u);
        }

        function updateAssets(text, type) {
            for (let word in wordAssets) {
                if (text.toLowerCase().includes(word.toLowerCase())) {
                    wordAssets[word].heat = (type === 'HEAVY') ? 'Overheat' : 'Warm';
                    wordAssets[word].level += (type === 'HEAVY') ? 2 : 1;
                    renderWord(word);
                }
            }
        }

        document.getElementById('sendBtn').onclick = () => handleInput(document.getElementById('userInput').value, 'USER_INPUT');
        document.getElementById('userInput').onkeypress = (e) => { if (e.key === 'Enter') handleInput(e.target.value, 'USER_INPUT'); };
    </script>
</body>

</html>