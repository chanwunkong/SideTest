<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HoldFocus - v10.14 Final Precision Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- 基礎樣式與滑桿控制 --- */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -7px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }

        #file-upload {
            display: none;
        }

        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .checkerboard {
            background-color: #f0f0f0;
            background-image: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%);
            background-size: 20px 20px;
        }

        .color-btn.selected {
            ring: 2px;
            ring-offset: 2px;
            ring-color: #3b82f6;
            transform: scale(1.15);
        }

        /* --- 畫布層級與轉化 --- */
        .canvas-stack {
            position: relative;
            width: 0;
            height: 0;
            max-width: none !important;
            max-height: none !important;
        }

        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            max-width: none !important;
            max-height: none !important;
        }

        #layer-bg {
            z-index: 1;
        }

        #layer-mask {
            z-index: 2;
            mix-blend-mode: normal;
        }

        #layer-ui {
            z-index: 3;
            pointer-events: none;
        }

        /* 裁切框樣式 */
        .crop-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .crop-frame {
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            position: relative;
            display: none;
        }

        .crop-frame::before {
            content: '';
            position: absolute;
            top: 33.33%;
            left: 0;
            right: 0;
            height: 33.33%;
            border-top: 1px dashed rgba(255, 255, 255, 0.3);
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .crop-frame::after {
            content: '';
            position: absolute;
            left: 33.33%;
            top: 0;
            bottom: 0;
            width: 33.33%;
            border-left: 1px dashed rgba(255, 255, 255, 0.3);
            border-right: 1px dashed rgba(255, 255, 255, 0.3);
        }

        #crop-inner-backdrop {
            position: absolute;
            inset: 0;
            z-index: 0;
            display: none;
        }

        .tool-btn.active {
            background-color: #2563eb;
            color: white;
        }

        .tool-btn {
            color: #6b7280;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .snap-line {
            position: absolute;
            background-color: #3b82f6;
            z-index: 70;
            pointer-events: none;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
        }

        #loupe {
            position: absolute;
            width: 130px;
            height: 130px;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: none;
            background: #000;
        }

        #canvas-container {
            touch-action: none;
            overflow: hidden;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 10px;
        }
    </style>
</head>

<body class="bg-gray-100 text-gray-800 h-screen flex flex-col overflow-hidden font-sans select-none">

    <!-- 頂部欄 -->
    <header
        class="bg-white border-b border-gray-200 h-14 flex items-center justify-between px-4 shrink-0 z-20 shadow-sm">
        <div class="flex items-center gap-2 overflow-hidden">
            <h1 class="text-base font-bold text-gray-900 truncate">HoldFocus <span
                    class="text-xs font-normal text-gray-500 ml-1">v10.14</span></h1>
            <div class="flex ml-2 border-l border-gray-200 pl-2 space-x-1">
                <button id="undo-btn" class="p-1.5 text-gray-500 disabled:opacity-20 transition-opacity" disabled>
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                    </svg>
                </button>
                <button id="redo-btn" class="p-1.5 text-gray-500 disabled:opacity-20 transition-opacity" disabled>
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 10h-10a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div class="flex space-x-2 items-center">
            <label for="file-upload"
                class="cursor-pointer bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1.5 rounded text-sm font-bold transition-colors">開啟</label>
            <input id="file-upload" type="file" accept="image/*">
            <button id="download-btn"
                class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded text-sm font-bold transition-colors disabled:opacity-50 shadow-sm"
                disabled>下載</button>
        </div>
    </header>

    <main class="flex-1 flex flex-col-reverse md:flex-row overflow-hidden relative">

        <!-- 側邊欄 -->
        <aside
            class="w-full md:w-80 bg-white border-t md:border-t-0 md:border-r border-gray-200 flex flex-col z-10 shrink-0 h-[45%] md:h-full transition-all duration-300 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">
            <div class="flex border-b border-gray-200 shrink-0">
                <button id="tab-route"
                    class="flex-1 py-3 text-sm font-bold text-blue-600 border-b-2 border-blue-600 bg-blue-50 transition-colors">路線編輯</button>
                <button id="tab-text"
                    class="flex-1 py-3 text-sm font-medium text-gray-500 hover:text-gray-700 transition-colors">文字/標記</button>
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar relative p-4">
                <!-- 路線分頁 -->
                <div id="panel-route" class="space-y-4">
                    <div class="bg-blue-50 border border-blue-100 rounded-lg p-3 text-center md:text-left">
                        <p class="text-xs text-blue-800 font-bold leading-relaxed">1. 右上角開啟照片<br>2. 點擊下方 <b
                                class="inline-flex items-center justify-center w-4 h-4 bg-blue-600 text-white rounded-full text-[10px] align-middle shadow-sm">+</b>
                            號，開始圈選岩點</p>
                    </div>

                    <div class="flex-1 flex flex-col min-h-0">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-bold text-gray-700">已選岩點</h3>
                        </div>
                        <div id="color-list" class="space-y-2 pb-2 overflow-y-auto">
                            <div
                                class="text-center py-6 text-gray-400 text-sm italic border-2 border-dashed border-gray-100 rounded-lg">
                                尚未圈選</div>
                        </div>
                    </div>

                    <div id="brush-controls" class="hidden border-t border-gray-200 pt-3">
                        <div class="flex justify-between mb-1"><label
                                class="text-xs font-bold text-blue-800 uppercase">橡皮擦大小</label><span id="brush-size-val"
                                class="text-xs text-blue-600 font-mono">20px</span></div>
                        <div class="slider-group flex items-center">
                            <button class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                onclick="app.adjSlider('brush-size', -5)">-</button>
                            <input type="range" id="brush-size" min="5" max="100" value="20"
                                class="accent-blue-600 flex-1 mx-2">
                            <button class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                onclick="app.adjSlider('brush-size', 5)">+</button>
                        </div>
                    </div>

                    <div class="border-t border-gray-200 pt-3">
                        <details class="group">
                            <summary
                                class="flex justify-between items-center font-bold text-xs text-gray-500 cursor-pointer list-none py-1">
                                <span>影像調整 (全域)</span>
                                <span class="transition-transform group-open:rotate-180 duration-200"><svg
                                        class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M19 9l-7 7-7-7"></path>
                                    </svg></span>
                            </summary>
                            <div class="mt-3 space-y-4 pb-2 px-1">
                                <div>
                                    <div class="flex justify-between mb-1"><label
                                            class="text-xs font-medium text-gray-600">對比度</label><span id="contrast-val"
                                            class="text-xs text-gray-400">100%</span></div>
                                    <div class="slider-group flex items-center">
                                        <button
                                            class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                            onclick="app.adjSlider('contrast', -5)">-</button>
                                        <input type="range" id="contrast" min="50" max="150" value="100"
                                            class="accent-gray-600 flex-1 mx-2">
                                        <button
                                            class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                            onclick="app.adjSlider('contrast', 5)">+</button>
                                    </div>
                                </div>
                                <div class="w-full h-px bg-gray-100"></div>
                                <div class="space-y-3">
                                    <h4 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">背景風格</h4>
                                    <div>
                                        <div class="flex justify-between mb-1"><label
                                                class="text-xs font-medium text-gray-600">飽和度</label><span
                                                id="bg-sat-val" class="text-xs text-gray-400">0%</span></div>
                                        <div class="slider-group flex items-center">
                                            <button
                                                class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                                onclick="app.adjSlider('bg-sat', -5)">-</button>
                                            <input type="range" id="bg-sat" min="0" max="100" value="0"
                                                class="accent-gray-600 flex-1 mx-2">
                                            <button
                                                class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                                onclick="app.adjSlider('bg-sat', 5)">+</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="flex justify-between mb-1"><label
                                                class="text-xs font-medium text-gray-600">壓暗</label><span
                                                id="bg-dim-val" class="text-xs text-gray-400">0%</span></div>
                                        <div class="slider-group flex items-center">
                                            <button
                                                class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                                onclick="app.adjSlider('bg-dim', -5)">-</button>
                                            <input type="range" id="bg-dim" min="0" max="90" value="0"
                                                class="accent-gray-600 flex-1 mx-2">
                                            <button
                                                class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                                onclick="app.adjSlider('bg-dim', 5)">+</button>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="flex justify-between mb-1"><label
                                                class="text-xs font-medium text-gray-600">模糊</label><span
                                                id="bg-blur-val" class="text-xs text-gray-400">0px</span></div>
                                        <div class="slider-group flex items-center">
                                            <button
                                                class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                                onclick="app.adjSlider('bg-blur', -1)">-</button>
                                            <input type="range" id="bg-blur" min="0" max="20" value="0"
                                                class="accent-gray-600 flex-1 mx-2">
                                            <button
                                                class="slider-btn px-2 text-gray-500 font-bold hover:bg-gray-100 rounded"
                                                onclick="app.adjSlider('bg-blur', 1)">+</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </details>
                    </div>
                </div>

                <!-- 文字分頁 -->
                <div id="panel-text" class="space-y-4 hidden">
                    <div>
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">標記 (Tags)</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="add-start-tag"
                                class="flex items-center justify-center gap-2 bg-green-50 text-green-700 py-3 rounded-lg text-sm font-bold border border-green-200 shadow-sm active:scale-95">S
                                Start</button>
                            <button id="add-top-tag"
                                class="flex items-center justify-center gap-2 bg-red-50 text-red-700 py-3 rounded-lg text-sm font-bold border border-red-200 shadow-sm active:scale-95">T
                                Top</button>
                        </div>
                    </div>
                    <div class="border-t border-gray-200 pt-4">
                        <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">文字 (Text)</h3>
                        <div class="flex gap-2 mb-3">
                            <input type="text" id="text-input" placeholder="輸入文字..."
                                class="flex-1 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:border-blue-500 outline-none" />
                            <button id="add-text-btn"
                                class="bg-gray-800 text-white px-4 rounded-lg text-sm font-bold active:scale-95">+</button>
                        </div>
                        <div id="text-controls"
                            class="space-y-4 opacity-50 pointer-events-none bg-gray-50 p-3 rounded-xl border border-gray-200">
                            <div class="flex flex-wrap gap-2" id="color-palette"></div>
                            <div class="flex items-center justify-between">
                                <label class="flex items-center cursor-pointer">
                                    <div class="relative"><input type="checkbox" id="text-bg-toggle" class="sr-only">
                                        <div class="w-8 h-4 bg-gray-300 rounded-full shadow-inner transition-colors"
                                            id="text-bg-track"></div>
                                        <div class="absolute left-0.5 top-0.5 w-3 h-3 bg-white rounded-full shadow transition-transform"
                                            id="text-bg-dot"></div>
                                    </div>
                                    <div class="ml-2 text-xs font-medium text-gray-700">底色</div>
                                </label>
                                <div class="flex items-center gap-2">
                                    <span class="text-xs text-gray-500 font-mono">Size</span>
                                    <div class="slider-group w-24 flex items-center">
                                        <button class="slider-btn text-gray-500 px-1"
                                            onclick="app.adjSlider('text-size', -5)">-</button>
                                        <input type="range" id="text-size" min="10" max="300" value="40"
                                            class="accent-gray-700 flex-1">
                                        <button class="slider-btn text-gray-500 px-1"
                                            onclick="app.adjSlider('text-size', 5)">+</button>
                                    </div>
                                </div>
                            </div>
                            <button id="delete-item-btn"
                                class="w-full bg-white border border-red-200 text-red-500 py-2 rounded-lg text-xs font-bold active:bg-red-50">刪除物件</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="processing-bar"
                class="bg-blue-600 text-white text-xs py-2 px-4 flex items-center justify-center gap-2 hidden shrink-0 shadow-inner">
                <div class="loader w-3 h-3 border-2 border-white border-t-transparent"></div><span>處理中...</span>
            </div>
        </aside>

        <!-- 畫布區域 -->
        <section class="flex-1 bg-gray-800 relative overflow-hidden h-[55%] md:h-full checkerboard"
            id="canvas-container">
            <!-- 裁切底色背景層 -->
            <div id="crop-canvas-bg" class="absolute inset-0"></div>

            <div id="canvas-transform-root"
                class="w-full h-full flex items-center justify-center origin-center transition-transform duration-75 ease-linear relative z-10">
                <div id="canvas-wrapper" class="canvas-stack shadow-2xl hidden shrink-0">
                    <!-- 圖片內層底色 -->
                    <div id="crop-inner-backdrop" class="absolute inset-0 z-0"></div>
                    <canvas id="layer-bg" class="layer"></canvas>
                    <canvas id="layer-mask" class="layer"></canvas>
                    <canvas id="layer-ui" class="layer"></canvas>
                </div>
            </div>

            <!-- 固定導引線與裁切層 (用於畫布 Pan) -->
            <div id="guide-v" class="snap-line w-px h-full top-0 left-1/2 hidden transform -translate-x-1/2"></div>
            <div id="guide-h" class="snap-line h-px w-full left-0 top-1/2 hidden transform -translate-y-1/2"></div>
            <div id="crop-mask-container" class="crop-overlay hidden">
                <div id="crop-frame" class="crop-frame"></div>
            </div>

            <!-- 懸浮工具欄 -->
            <div id="floating-toolbar"
                class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur-md shadow-xl rounded-full px-4 py-2 flex items-center gap-4 z-[60] border border-gray-200 transition-all duration-300">
                <div id="tool-switcher" class="flex bg-gray-100 rounded-full p-1">
                    <button id="tool-hand" class="tool-btn p-2 rounded-full active:bg-gray-200"><svg class="w-5 h-5"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11">
                            </path>
                        </svg></button>
                    <button id="tool-lasso" class="tool-btn p-2 rounded-full active:bg-gray-200"><svg class="w-5 h-5"
                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                        </svg></button>
                    <button id="tool-eraser" class="tool-btn p-2 rounded-full active:bg-gray-200" title="Eraser">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" viewBox="0 0 24 24">
                            <path
                                d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21">
                            </path>
                            <path d="M22 21H7"></path>
                            <path d="m5 11 9 9"></path>
                        </svg>
                    </button>
                </div>
                <div class="w-px h-6 bg-gray-300"></div>
                <div class="flex items-center gap-2">
                    <button id="crop-btn"
                        class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-600 font-bold active:bg-gray-200"><svg
                            class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                            </path>
                        </svg></button>
                    <button id="crop-bg-color"
                        class="hidden w-6 h-6 rounded-full border border-gray-300 bg-white shadow-sm"
                        title="Toggle Backdrop Color"></button>
                    <span id="crop-label" class="text-[10px] text-blue-600 font-mono hidden">Orig</span>
                </div>
            </div>

            <div id="placeholder-msg"
                class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-0">
                <div
                    class="mx-auto w-12 h-12 bg-gray-700/50 text-white/50 rounded-full flex items-center justify-center mb-4 backdrop-blur-sm">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                        </path>
                    </svg>
                </div>
                <h3 class="text-sm font-bold text-white/80">請開啟照片</h3>
            </div>

            <div id="loupe">
                <canvas id="loupe-canvas"></canvas>
            </div>
        </section>
    </main>

    <script>
        // --- 定義常量 ---
        const COLORS_LIST = ['#EC4899', '#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#FFFFFF', '#000000'];
        const CROPS = [
            { label: 'Orig', w: 0, h: 0 },
            { label: '1:1', w: 1, h: 1 },
            { label: '4:5', w: 4, h: 5 },
            { label: '16:9', w: 16, h: 9 }
        ];

        // --- Web Worker 邏輯 ---
        const workerCode = `
            self.onmessage = function(e) {
                const { type, sel, w, h, bgData } = e.data;
                if (type === 'CALC_MASK') {
                    const res = calculateMaskInternal(sel, w, h, bgData);
                    const borderMask = sel.params.border ? getBorderInternal(res.mask, w, h, sel.params.borderThickness || 5) : null;
                    self.postMessage({ id: sel.id, mask: res.mask, borderMask, detectedColor: res.color });
                }
            };
            function colorDist(r1, g1, b1, r2, g2, b2) {
                const dr = r1 - r2, dg = g1 - g2, db = b1 - b2;
                return Math.sqrt(2 * dr * dr + 4 * dg * dg + 3 * db * db);
            }
            function isPointInPolygon(p, poly) {
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].x, yi = poly[i].y;
                    const xj = poly[j].x, yj = poly[j].y;
                    const intersect = ((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            function calculateMaskInternal(sel, w, h, bgData) {
                const mask = new Uint8Array(w * h), visited = new Uint8Array(w * h);
                const tolerance = sel.params.tolerance, palette = [], queue = [];
                let rSum = 0, gSum = 0, bSum = 0, count = 0;
                if (sel.seeds && sel.seeds.length > 0) {
                    const paths = Array.isArray(sel.seeds[0]) ? sel.seeds : [sel.seeds];
                    paths.forEach(path => {
                        if (path.length < 3) return;
                        let minX = w, maxX = 0, minY = h, maxY = 0;
                        path.forEach(p => { if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x; if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y; });
                        minX = Math.max(0, Math.floor(minX)); minY = Math.max(0, Math.floor(minY));
                        maxX = Math.min(w, Math.ceil(maxX)); maxY = Math.min(h, Math.ceil(maxY));
                        for (let y = minY; y < maxY; y++) {
                            const rOff = y * w;
                            for (let x = minX; x < maxX; x++) {
                                if (isPointInPolygon({ x, y }, path)) {
                                    const idx = rOff + x; mask[idx] = 1;
                                    if (visited[idx] === 0) {
                                        visited[idx] = 1; queue.push(x, y);
                                        const pIdx = idx * 4; rSum += bgData[pIdx]; gSum += bgData[pIdx+1]; bSum += bgData[pIdx+2]; count++;
                                        if (palette.length < 400 && (x + y) % 4 === 0) palette.push({ r: bgData[pIdx], g: bgData[pIdx+1], b: bgData[pIdx+2] });
                                    }
                                }
                            }
                        }
                    });
                }
                if (palette.length > 0) {
                    let head = 0; const dx = [0, 1, 0, -1], dy = [-1, 0, 1, 0];
                    while (head < queue.length) {
                        const x = queue[head++], y = queue[head++];
                        for (let i = 0; i < 4; i++) {
                            const nx = x + dx[i], ny = y + dy[i];
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                const nIdx = ny * w + nx;
                                if (visited[nIdx] === 0) {
                                    visited[nIdx] = 1; const pIdx = nIdx * 4;
                                    const r = bgData[pIdx], g = bgData[pIdx+1], b = bgData[pIdx+2];
                                    let match = false;
                                    for(let s=0; s<palette.length; s+=2) if (colorDist(r, g, b, palette[s].r, palette[s].g, palette[s].b) <= tolerance) { match = true; break; }
                                    if (match) { mask[nIdx] = 1; queue.push(nx, ny); rSum += r; gSum += g; bSum += b; count++; }
                                }
                            }
                        }
                    }
                }
                if (sel.params.expand > 0) expandInternal(mask, w, h, sel.params.expand);
                if (sel.params.fillHoles) fillHolesInternal(mask, w, h);
                if (sel.manualEdits) sel.manualEdits.forEach(edit => applyEditInternal(mask, w, h, edit));
                const final = keepLargestInternal(mask, w, h);
                const hex = count > 0 ? '#' + [rSum/count, gSum/count, bSum/count].map(v => Math.round(v).toString(16).padStart(2, '0')).join('') : '#EC4899';
                return { mask: final, color: hex };
            }
            function expandInternal(mask, w, h, rad) {
                const old = new Uint8Array(mask);
                for(let y=0; y<h; y++) {
                    const row = y * w;
                    for(let x=0; x<w; x++) {
                        if(old[row + x]) {
                            let isE = (x==0 || x==w-1 || y==0 || y==h-1);
                            if(!isE) if(!old[row+x-1] || !old[row+x+1] || !old[row-w+x] || !old[row+w+x]) isE = true;
                            if (isE) for(let ky=-rad; ky<=rad; ky++) for(let kx=-rad; kx<=rad; kx++) {
                                const ny = y+ky, nx = x+kx; if(nx>=0 && nx<w && ny>=0 && ny<h) mask[ny*w+nx] = 1;
                            }
                        }
                    }
                }
            }
            function fillHolesInternal(mask, w, h) {
                const visited = new Uint8Array(w*h), q = [];
                for(let x=0; x<w; x++) { if(!mask[x]) { q.push(x,0); visited[x]=1; } if(!mask[(h-1)*w+x]) { q.push(x,h-1); visited[(h-1)*w+x]=1; } }
                for(let y=0; y<h; y++) { if(!mask[y*w] && !visited[y*w]) { q.push(0,y); visited[y*w]=1; } if(!mask[y*w+w-1] && !visited[y*w+w-1]) { q.push(w-1,y); visited[y*w+w-1]=1; } }
                let head = 0; const dx=[1,-1,0,0], dy=[0,0,1,-1];
                while(head < q.length) {
                    const x = q[head++], y = q[head++];
                    for(let i=0; i<4; i++) {
                        const nx=x+dx[i], ny=y+dy[i];
                        if(nx>=0 && nx<w && ny>=0 && ny<h && !mask[ny*w+nx] && !visited[ny*w+nx]) { visited[ny*w+nx] = 1; q.push(nx,ny); }
                    }
                }
                for(let i=0; i<w*h; i++) if(!mask[i] && !visited[i]) mask[i] = 1;
            }
            function applyEditInternal(mask, w, h, edit) {
                const { type, points, size } = edit, rad = size / 2, r2 = rad * rad;
                points.forEach(p => {
                    const cx = Math.floor(p.x), cy = Math.floor(p.y);
                    for(let y=Math.floor(cy-rad); y<cy+rad; y++) for(let x=Math.floor(cx-rad); x<cx+rad; x++) {
                        if (x>=0 && x<w && y>=0 && y<h && (x-cx)*(x-cx) + (y-cy)*(y-cy) <= r2) mask[y*w+x] = (type === 'add' ? 1 : 0);
                    }
                });
            }
            function keepLargestInternal(mask, w, h) {
                const visited = new Uint8Array(w * h); let maxC = 0, maxL = 0, curL = 1;
                const labels = new Int32Array(w * h);
                for (let i = 0; i < w * h; i++) {
                    if (mask[i] === 1 && visited[i] === 0) {
                        let c = 0; const q = [i]; visited[i] = 1; labels[i] = curL;
                        let head = 0;
                        while(head < q.length) {
                            const idx = q[head++]; c++; const cx = idx % w, cy = Math.floor(idx / w);
                            const dx = [1, -1, 0, 0], dy = [0, 0, 1, -1];
                            for(let d=0; d<4; d++) {
                                const nx = cx + dx[d], ny = cy + dy[d];
                                if(nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                    const nIdx = ny * w + nx; if(mask[nIdx] === 1 && visited[nIdx] === 0) { visited[nIdx] = 1; labels[nIdx] = curL; q.push(nIdx); }
                                }
                            }
                        }
                        if (c > maxC) { maxC = c; maxL = curL; }
                        curL++;
                    }
                }
                const res = new Uint8Array(w*h);
                if (maxL > 0) for (let i = 0; i < w * h; i++) if (labels[i] === maxL) res[i] = 1;
                return res;
            }
            function getBorderInternal(mask, w, h, thickness) {
                const expanded = new Uint8Array(mask.length); expanded.set(mask);
                expandInternal(expanded, w, h, thickness);
                const border = new Uint8Array(mask.length);
                for(let i=0; i<mask.length; i++) if (expanded[i] && !mask[i]) border[i] = 1;
                return border;
            }
        `;

        class StateManager {
            constructor(onHistoryChange) {
                this.history = []; this.historyIndex = -1; this.onHistoryChange = onHistoryChange;
                this.data = { filters: { contrast: 100, bgSat: 0, bgDim: 0, bgBlur: 0 }, selections: [], objects: [], crop: { index: 0, bgWhite: true }, nextSelId: 1, nextObjId: 1 };
                this.view = { scale: 1, x: 0, y: 0, tool: 'lasso', activeTab: 'route', activeSelId: null, activeObjId: null, brushSize: 20, isDragging: false, dragType: null, tempPath: [], snapObjX: false, snapObjY: false };
            }
            pushHistory() {
                const safe = this.data.selections.map(s => { const { mask, borderMask, ...rest } = s; return rest; });
                const snapshot = JSON.stringify({ ...this.data, selections: safe });
                if (this.historyIndex < this.history.length - 1) this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(snapshot); this.historyIndex++;
                if (this.history.length > 20) { this.history.shift(); this.historyIndex--; }
                this.onHistoryChange();
            }
            undo() { if (this.historyIndex > 0) { this.historyIndex--; this.restore(this.history[this.historyIndex]); } }
            redo() { if (this.historyIndex < this.history.length - 1) { this.historyIndex++; this.restore(this.history[this.historyIndex]); } }
            restore(json) { this.data = JSON.parse(json); this.onHistoryChange(true); }
        }

        class LayerManager {
            constructor() {
                this.bgCtx = document.getElementById('layer-bg')?.getContext('2d');
                this.maskCtx = document.getElementById('layer-mask')?.getContext('2d');
                this.uiCtx = document.getElementById('layer-ui')?.getContext('2d');
                const loupeC = document.getElementById('loupe-canvas');
                this.loupeCtx = loupeC ? loupeC.getContext('2d') : null;
                this.width = this.height = 0;
            }
            resize(w, h) {
                this.width = w; this.height = h;
                const wrapper = document.getElementById('canvas-wrapper');
                if (wrapper) { wrapper.style.width = w + 'px'; wrapper.style.height = h + 'px'; }
                [this.bgCtx, this.maskCtx, this.uiCtx].forEach(ctx => { if (ctx) { ctx.canvas.width = w; ctx.canvas.height = h; } });
            }
            drawBg(img, filters) {
                if (!img || !this.bgCtx) return;
                const ctx = this.bgCtx; ctx.clearRect(0, 0, this.width, this.height);
                ctx.filter = `contrast(${filters.contrast}%)`; ctx.drawImage(img, 0, 0); ctx.filter = 'none';
                this.bgBuffer = ctx.getImageData(0, 0, this.width, this.height).data;
            }
            drawMasks(selections, filters) {
                if (!this.bgBuffer || !this.maskCtx) return;
                const ctx = this.maskCtx; ctx.clearRect(0, 0, this.width, this.height);
                ctx.save(); ctx.filter = `saturate(${filters.bgSat}%) brightness(${100 - filters.bgDim}%) blur(${filters.bgBlur}px)`;
                ctx.drawImage(this.bgCtx.canvas, 0, 0); ctx.restore();
                ctx.globalCompositeOperation = 'destination-out';
                const tempC = document.createElement('canvas'); tempC.width = this.width; tempC.height = this.height;
                const tCtx = tempC.getContext('2d'); const iData = tCtx.createImageData(this.width, this.height);
                let hasM = false;
                selections.forEach(s => { if (s.mask) for (let i = 0; i < s.mask.length; i++) if (s.mask[i]) { iData.data[i * 4 + 3] = 255; hasM = true; } });
                if (hasM) { tCtx.putImageData(iData, 0, 0); ctx.save(); ctx.filter = 'blur(1.5px)'; ctx.drawImage(tempC, 0, 0); ctx.restore(); }
                ctx.globalCompositeOperation = 'source-over';
                selections.forEach(s => {
                    if (s.params.border && s.borderMask) {
                        const bImg = ctx.createImageData(this.width, this.height);
                        let col = { r: 236, g: 72, b: 153 }; const res = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(s.params.borderColor || '#EC4899');
                        if (res) col = { r: parseInt(res[1], 16), g: parseInt(res[2], 16), b: parseInt(res[3], 16) };
                        for (let i = 0; i < s.borderMask.length; i++) if (s.borderMask[i]) { const p = i * 4; bImg.data[p] = col.r; bImg.data[p + 1] = col.g; bImg.data[p + 2] = col.b; bImg.data[p + 3] = 255; }
                        const bC = document.createElement('canvas'); bC.width = this.width; bC.height = this.height;
                        bC.getContext('2d').putImageData(bImg, 0, 0); ctx.drawImage(bC, 0, 0);
                    }
                });
            }
            drawUi(state) {
                if (!this.uiCtx) return;
                const ctx = this.uiCtx; ctx.clearRect(0, 0, this.width, this.height);

                // 拖曳物體的對準輔助線 (針對圖片中心)
                if (state.view.isDragging && state.view.dragType === 'object') {
                    const cx = this.width / 2, cy = this.height / 2;
                    ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2 / state.view.scale; ctx.setLineDash([5, 5]);
                    if (state.view.snapObjX) { ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, this.height); ctx.stroke(); }
                    if (state.view.snapObjY) { ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(this.width, cy); ctx.stroke(); }
                    ctx.setLineDash([]);
                }

                if (state.view.isDragging && state.view.tempPath.length > 0) {
                    const p = state.view.tempPath; ctx.beginPath(); ctx.moveTo(p[0].x, p[0].y);
                    for (let i = 1; i < p.length; i++) ctx.lineTo(p[i].x, p[i].y);
                    if (state.view.dragType === 'lasso') { ctx.strokeStyle = 'rgba(255,230,0,0.9)'; ctx.lineWidth = 2 / state.view.scale; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); }
                    else if (state.view.dragType === 'eraser') { ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = state.view.brushSize; ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.stroke(); }
                }

                state.data.objects.forEach(obj => {
                    const isS = obj.id === state.view.activeObjId && state.view.activeTab === 'text';
                    ctx.save(); ctx.translate(obj.x, obj.y);
                    if (obj.type === 'text') {
                        ctx.font = `bold ${obj.fontSize}px sans-serif`; ctx.textBaseline = 'top'; const m = ctx.measureText(obj.text);
                        if (obj.bgColor) { ctx.fillStyle = obj.bgColor; ctx.roundRect(-8, -8, m.width + 16, obj.fontSize + 12, 8); ctx.fill(); }
                        ctx.fillStyle = obj.color; ctx.fillText(obj.text, 0, 0);
                        if (isS) { ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]); ctx.strokeRect(-4, -4, m.width + 8, obj.fontSize + 8); }
                    } else {
                        const s = obj.fontSize / 60; ctx.scale(s, s); ctx.fillStyle = obj.color; ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 4;
                        ctx.save(); ctx.rotate(-0.26); ctx.fillRect(-25, -8, 50, 16); ctx.rotate(0.52); ctx.fillRect(-25, -8, 50, 16); ctx.restore();
                        ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(obj.text, 0, 0);
                        if (isS) { ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 3; ctx.setLineDash([5, 3]); ctx.strokeRect(-30, -30, 60, 60); }
                    }
                    ctx.restore();
                });
            }
            updateLoupe(pos, scale) {
                if (!this.loupeCtx || !this.bgCtx) return;
                const container = document.getElementById('canvas-container');
                const rect = container.getBoundingClientRect();
                const l = document.getElementById('loupe'), lc = document.getElementById('loupe-canvas');
                l.style.display = 'block';
                l.style.left = (pos.screenX - rect.left - 65) + 'px';
                l.style.top = (pos.screenY - rect.top - 150) + 'px';
                lc.width = lc.height = 130;
                const ctx = this.loupeCtx; ctx.clearRect(0, 0, 130, 130);
                [this.bgCtx, this.maskCtx, this.uiCtx].forEach(c => {
                    if (c) ctx.drawImage(c.canvas, pos.x - 32 / scale, pos.y - 32 / scale, 64 / scale, 64 / scale, 0, 0, 130, 130);
                });
                ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(65, 0); ctx.lineTo(65, 130); ctx.moveTo(0, 65); ctx.lineTo(130, 65); ctx.stroke();
            }
            hideLoupe() { const l = document.getElementById('loupe'); if (l) l.style.display = 'none'; }
        }

        class App {
            constructor() {
                this.state = new StateManager((f) => {
                    this.updateUI(f);
                    this.flags.ui = true;
                    if (f) { this.flags.bg = true; this.flags.mask = true; }
                });
                this.layers = new LayerManager();
                this.flags = { bg: false, mask: false, ui: false };
                this.els = this.cacheDOM();
                this.initWorker(); this.initListeners(); this.loop();
            }
            initWorker() {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                this.worker = new Worker(URL.createObjectURL(blob));
                this.worker.onmessage = (e) => {
                    const sel = this.state.data.selections.find(s => s.id === e.data.id);
                    if (sel) {
                        sel.mask = e.data.mask;
                        sel.borderMask = e.data.borderMask;
                        sel.detectedColor = e.data.detectedColor;
                    }
                    this.flags.mask = true; this.updateUI();
                    document.getElementById('processing-bar')?.classList.add('hidden');
                };
            }
            cacheDOM() {
                const ids = ['contrast', 'bg-sat', 'bg-dim', 'bg-blur', 'tool-hand', 'tool-lasso', 'tool-eraser', 'brush-size', 'text-input', 'text-size', 'text-bg-toggle', 'color-palette', 'color-list', 'file-upload', 'download-btn', 'canvas-container', 'canvas-transform-root', 'panel-route', 'panel-text', 'tab-route', 'tab-text', 'undo-btn', 'redo-btn', 'delete-item-btn', 'crop-btn', 'crop-frame', 'crop-bg-color', 'guide-v', 'guide-h', 'crop-mask-container', 'crop-inner-backdrop', 'layer-ui'];
                const els = {}; ids.forEach(id => els[id] = document.getElementById(id)); return els;
            }
            initListeners() {
                this.els['file-upload']?.addEventListener('change', e => this.loadFile(e.target.files[0]));
                this.els['download-btn']?.addEventListener('click', () => this.export());
                this.els['contrast']?.addEventListener('input', e => { this.state.data.filters.contrast = parseInt(e.target.value); const v = document.getElementById('contrast-val'); if (v) v.innerText = e.target.value + '%'; this.flags.bg = this.flags.mask = true; });
                ['bg-sat', 'bg-dim', 'bg-blur'].forEach(id => {
                    this.els[id]?.addEventListener('input', e => {
                        const k = id.replace('-s', 'S').replace('-d', 'D').replace('-b', 'B').replace('-', '');
                        this.state.data.filters[k] = parseFloat(e.target.value); const v = document.getElementById(`${id}-val`); if (v) v.innerText = e.target.value + (id.includes('blur') ? 'px' : '%'); this.flags.mask = true;
                    });
                });
                ['hand', 'lasso', 'eraser'].forEach(t => {
                    const btn = document.getElementById(`tool-${t}`);
                    if (btn) btn.addEventListener('click', (e) => { e.preventDefault(); this.setTool(t); });
                });
                this.els['brush-size']?.addEventListener('input', e => { this.state.view.brushSize = parseInt(e.target.value); const v = document.getElementById('brush-size-val'); if (v) v.innerText = e.target.value + 'px'; });
                this.els['tab-route']?.addEventListener('click', () => this.switchTab('route'));
                this.els['tab-text']?.addEventListener('click', () => this.switchTab('text'));
                document.getElementById('add-text-btn')?.addEventListener('click', () => this.addObj('text'));
                document.getElementById('add-start-tag')?.addEventListener('click', () => this.addObj('tag', 'S', '#10B981'));
                document.getElementById('add-top-tag')?.addEventListener('click', () => this.addObj('tag', 'T', '#EF4444'));
                this.els['delete-item-btn']?.addEventListener('click', () => { if (this.state.view.activeObjId) { this.state.data.objects = this.state.data.objects.filter(o => o.id !== this.state.view.activeObjId); this.state.view.activeObjId = null; this.flags.ui = true; this.updateUI(); this.state.pushHistory(); } });

                this.els['text-size']?.addEventListener('input', e => { const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId); if (o) { o.fontSize = parseInt(e.target.value); this.flags.ui = true; } });
                this.els['text-bg-toggle']?.addEventListener('change', e => { const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId); if (o) { o.bgColor = e.target.checked ? 'rgba(0,0,0,0.6)' : null; this.flags.ui = true; this.updateUI(); this.state.pushHistory(); } });

                COLORS_LIST.forEach(c => { const b = document.createElement('button'); b.className = 'color-btn w-6 h-6 rounded-full border border-gray-200 shadow-sm transition-transform'; b.style.backgroundColor = c; b.onclick = () => { const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId); if (o) { o.color = c; this.flags.ui = true; this.updateUI(); this.state.pushHistory(); } }; this.els['color-palette']?.appendChild(b); });

                const cc = this.els['canvas-container'];
                if (cc) {
                    cc.addEventListener('pointerdown', e => { this.pointerDown(e); });
                    window.addEventListener('pointermove', e => { this.pointerMove(e); });
                    window.addEventListener('pointerup', e => { this.pointerUp(e); });
                    cc.addEventListener('wheel', e => { e.preventDefault(); this.state.view.scale = Math.max(0.1, Math.min(5, this.state.view.scale * (e.deltaY > 0 ? 0.9 : 1.1))); this.updateTransform(); }, { passive: false });
                }
                this.els['undo-btn']?.addEventListener('click', () => this.state.undo());
                this.els['redo-btn']?.addEventListener('click', () => this.state.redo());
                this.els['crop-btn']?.addEventListener('click', () => this.toggleCrop());
                this.els['crop-bg-color']?.addEventListener('click', () => this.toggleCropBg());
            }
            getCoords(e) {
                const uiLayer = document.getElementById('layer-ui');
                if (!uiLayer) return { x: 0, y: 0, screenX: e.clientX, screenY: e.clientY };
                const r = uiLayer.getBoundingClientRect();
                return { x: (e.clientX - r.left) * (this.layers.width / r.width), y: (e.clientY - r.top) * (this.layers.height / r.height), screenX: e.clientX, screenY: e.clientY };
            }
            loadFile(file) {
                if (!file) return; const r = new FileReader();
                r.onload = e => {
                    const img = new Image(); img.onload = () => {
                        this.img = img; this.layers.resize(img.naturalWidth, img.naturalHeight); this.layers.drawBg(img, this.state.data.filters);
                        this.state.data.selections = []; this.state.data.objects = []; this.state.history = []; this.state.historyIndex = -1; this.state.pushHistory();
                        const cc = this.els['canvas-container'];
                        if (cc) this.state.view.scale = Math.min((cc.clientWidth - 20) / img.naturalWidth, (cc.clientHeight - 20) / img.naturalHeight);
                        this.state.view.x = 0; this.state.view.y = 0;
                        this.updateTransform();
                        document.getElementById('canvas-wrapper')?.classList.remove('hidden');
                        document.getElementById('placeholder-msg')?.classList.add('hidden');
                        if (this.els['download-btn']) this.els['download-btn'].disabled = false;
                        this.fullRedraw();
                    }; img.src = e.target.result;
                }; r.readAsDataURL(file);
            }
            loop() {
                if (this.flags.bg) { this.layers.drawBg(this.img, this.state.data.filters); this.flags.bg = false; }
                if (this.flags.mask) { this.layers.drawMasks(this.state.data.selections, this.state.data.filters); this.flags.mask = false; }
                if (this.flags.ui) { this.layers.drawUi(this.state); this.flags.ui = false; }
                requestAnimationFrame(() => this.loop());
            }
            fullRedraw() { this.flags.bg = this.flags.mask = this.flags.ui = true; }
            setTool(t) {
                this.state.view.tool = t;
                ['hand', 'lasso', 'eraser'].forEach(tool => {
                    const btn = document.getElementById(`tool-${tool}`);
                    if (btn) { btn.classList.toggle('active', t === tool); btn.classList.toggle('text-white', t === tool); }
                });
                if (this.els['canvas-container']) this.els['canvas-container'].style.cursor = t === 'hand' ? 'grab' : 'crosshair';
                if (this.els['brush-controls']) this.els['brush-controls'].classList.toggle('hidden', t !== 'eraser');
                this.flags.ui = true;
            }
            switchTab(t) {
                this.state.view.activeTab = t;
                if (this.els['panel-route']) this.els['panel-route'].classList.toggle('hidden', t !== 'route');
                if (this.els['panel-text']) this.els['panel-text'].classList.toggle('hidden', t !== 'text');
                if (this.els['tab-route']) this.els['tab-route'].className = t === 'route' ? "flex-1 py-3 text-sm font-bold text-blue-600 border-b-2 border-blue-600 bg-blue-50 transition-colors" : "flex-1 py-3 text-sm font-medium text-gray-500 hover:text-gray-700 transition-colors";
                if (this.els['tab-text']) this.els['tab-text'].className = t === 'text' ? "flex-1 py-3 text-sm font-bold text-blue-600 border-b-2 border-blue-600 bg-blue-50 transition-colors" : "flex-1 py-3 text-sm font-medium text-gray-500 hover:text-gray-700 transition-colors";
                this.setTool(t === 'route' ? 'lasso' : 'hand');
            }
            addObj(type, text, color) {
                const container = document.getElementById('canvas-container');
                if (!container) return;
                const rect = container.getBoundingClientRect();
                const p = this.getCoords({ clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2 });
                this.state.data.objects.push({ id: this.state.data.nextObjId++, type, x: p.x, y: p.y, text: text || (document.getElementById('text-input')?.value || 'Text'), color: color || '#FFFFFF', fontSize: type === 'tag' ? 60 : 40, bgColor: null });
                const ti = document.getElementById('text-input'); if (ti) ti.value = '';
                this.state.view.activeObjId = this.state.data.nextObjId - 1;
                this.state.pushHistory();
                this.flags.ui = true;
                this.layers.drawUi(this.state);
            }
            pointerDown(e) {
                if (!this.img) return; const p = this.getCoords(e); this.state.view.isDragging = true;
                if (this.state.view.activeTab === 'text') {
                    const hit = this.state.data.objects.slice().reverse().find(o => Math.hypot(o.x - p.x, o.y - p.y) < 50);
                    if (hit) { this.state.view.activeObjId = hit.id; this.state.view.dragType = 'object'; this.dragStart = { x: p.x, y: p.y, ox: hit.x, oy: hit.y }; }
                    else { this.state.view.activeObjId = null; this.state.view.dragType = 'pan'; this.dragStart = { cx: e.clientX, cy: e.clientY, vx: this.state.view.x, vy: this.state.view.y }; }
                } else {
                    if (this.state.view.tool === 'hand') { this.state.view.dragType = 'pan'; this.dragStart = { cx: e.clientX, cy: e.clientY, vx: this.state.view.x, vy: this.state.view.y }; }
                    else { this.state.view.dragType = this.state.view.tool; this.state.view.tempPath = [p]; this.layers.updateLoupe(p, this.state.view.scale); }
                }
                this.updateUI(); this.flags.ui = true;
            }
            pointerMove(e) {
                if (!this.state.view.isDragging) return; const p = this.getCoords(e);
                if (this.state.view.dragType === 'pan') {
                    let nx = this.dragStart.vx + (e.clientX - this.dragStart.cx), ny = this.dragStart.vy + (e.clientY - this.dragStart.cy);
                    const snapD = 20; let snapX = false, snapY = false;
                    if (Math.abs(nx) < snapD) { nx = 0; snapX = true; }
                    if (Math.abs(ny) < snapD) { ny = 0; snapY = true; }
                    if (this.els['guide-v']) this.els['guide-v'].classList.toggle('hidden', !snapX);
                    if (this.els['guide-h']) this.els['guide-h'].classList.toggle('hidden', !snapY);
                    this.state.view.x = nx; this.state.view.y = ny; this.updateTransform();
                } else if (this.state.view.dragType === 'object') {
                    const o = this.state.data.objects.find(obj => obj.id === this.state.view.activeObjId);
                    if (o) {
                        let nx = this.dragStart.ox + (p.x - this.dragStart.x), ny = this.dragStart.oy + (p.y - this.dragStart.y);
                        const snapD = 20 / this.state.view.scale;
                        this.state.view.snapObjX = false; this.state.view.snapObjY = false;
                        const cx = this.layers.width / 2, cy = this.layers.height / 2;
                        if (Math.abs(nx - cx) < snapD) { nx = cx; this.state.view.snapObjX = true; }
                        if (Math.abs(ny - cy) < snapD) { ny = cy; this.state.view.snapObjY = true; }
                        o.x = nx; o.y = ny; this.flags.ui = true;
                    }
                } else { this.state.view.tempPath.push(p); this.flags.ui = true; this.layers.updateLoupe(p, this.state.view.scale); }
            }
            isPointInPoly(p, poly) {
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].x, yi = poly[i].y, xj = poly[j].x, yj = poly[j].y;
                    const intersect = ((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            pointerUp() {
                if (!this.state.view.isDragging) return; this.state.view.isDragging = false;
                this.layers.hideLoupe();
                if (this.els['guide-v']) this.els['guide-v'].classList.add('hidden');
                if (this.els['guide-h']) this.els['guide-h'].classList.add('hidden');

                const type = this.state.view.dragType, path = this.state.view.tempPath;
                if (type === 'lasso' && path.length > 3) {
                    let mId = null; const w = this.layers.width, h = this.layers.height;
                    let minX = w, maxX = 0, minY = h, maxY = 0;
                    path.forEach(p => { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; });

                    for (const s of this.state.data.selections) {
                        if (!s.mask) continue;
                        // 1. 檢查圈選路徑是否直接碰到現有的岩點範圍 (加強容錯)
                        for (let i = 0; i < path.length; i += 2) {
                            const px = Math.floor(path[i].x), py = Math.floor(path[i].y);
                            for (let dy = -2; dy <= 2; dy++) for (let dx = -2; dx <= 2; dx++) {
                                const nx = px + dx, ny = py + dy;
                                if (nx >= 0 && nx < w && ny >= 0 && ny < h && s.mask[ny * w + nx]) { mId = s.id; break; }
                            }
                            if (mId) break;
                        }
                        if (mId) break;

                        // 2. 檢查現有的岩點是不是被「整個包在這次新畫的圈選範圍內」
                        let matched = false;
                        for (let y = Math.floor(minY); y <= Math.ceil(maxY); y += 4) {
                            for (let x = Math.floor(minX); x <= Math.ceil(maxX); x += 4) {
                                if (y >= 0 && y < h && x >= 0 && x < w && s.mask[y * w + x]) {
                                    if (this.isPointInPoly({ x, y }, path)) {
                                        mId = s.id; matched = true; break;
                                    }
                                }
                            }
                            if (matched) break;
                        }
                        if (mId) break;
                    }

                    let sel;
                    if (mId) { sel = this.state.data.selections.find(s => s.id === mId); sel.seeds.push(path); sel.mask = sel.borderMask = null; this.state.view.activeSelId = mId; }
                    else { const id = this.state.data.nextSelId++; sel = { id, seeds: [path], params: { tolerance: 60, expand: 0, fillHoles: true, border: true, borderThickness: 5, borderColor: '#EC4899' }, manualEdits: [], mask: null, borderMask: null, detectedColor: '#EC4899' }; this.state.data.selections.push(sel); this.state.view.activeSelId = id; }
                    this.requestWorker(sel); this.state.pushHistory(); this.updateUI();
                } else if (type === 'eraser' && path.length > 0) {
                    let sel = this.state.data.selections.find(s => s.id === this.state.view.activeSelId) || this.state.data.selections[this.state.data.selections.length - 1];
                    if (sel) { sel.manualEdits.push({ type: 'sub', points: path, size: this.state.view.brushSize }); sel.mask = sel.borderMask = null; this.requestWorker(sel); this.state.pushHistory(); }
                } else if (type === 'object') {
                    this.state.pushHistory();
                }

                this.state.view.tempPath = [];
                this.state.view.dragType = null;
                this.state.view.snapObjX = false;
                this.state.view.snapObjY = false;
                this.flags.ui = true;
            }
            adjSlider(id, v) {
                const el = document.getElementById(id);
                if (el) { el.value = parseFloat(el.value) + v; el.dispatchEvent(new Event('input')); el.dispatchEvent(new Event('change')); }
            }
            requestWorker(sel) { const pb = document.getElementById('processing-bar'); if (pb) pb.classList.remove('hidden'); this.worker.postMessage({ type: 'CALC_MASK', sel, w: this.layers.width, h: this.layers.height, bgData: this.layers.bgBuffer }); }
            updateTransform() { const r = document.getElementById('canvas-transform-root'); if (r) r.style.transform = `translate(${this.state.view.x}px, ${this.state.view.y}px) scale(${this.state.view.scale})`; }
            updateUI(force) {
                if (force) this.fullRedraw();
                if (this.els['undo-btn']) this.els['undo-btn'].disabled = this.state.historyIndex <= 0; if (this.els['redo-btn']) this.els['redo-btn'].disabled = this.state.historyIndex >= this.state.history.length - 1;
                const list = this.els['color-list']; if (!list) return; list.innerHTML = '';
                if (this.state.data.selections.length === 0) { list.innerHTML = `<div class="text-center py-6 text-gray-400 text-sm italic border-2 border-dashed border-gray-100 rounded-lg">尚未圈選</div>`; }
                else {
                    this.state.data.selections.forEach((sel, i) => {
                        const active = sel.id === this.state.view.activeSelId;
                        const div = document.createElement('div');
                        div.className = `list-item bg-white border ${active ? 'border-blue-500 shadow-md ring-1 ring-blue-100' : 'border-gray-200'} rounded-lg overflow-hidden mb-2`;
                        div.onclick = (e) => { if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') { this.state.view.activeSelId = (active ? null : sel.id); this.updateUI(); } };
                        const cols = COLORS_LIST.map(c => { const isS = (sel.params.borderColor || '#EC4899').toLowerCase() === c.toLowerCase(); return `<button class="w-6 h-6 rounded-full border border-gray-200 shadow-sm ${isS ? 'ring-2 ring-offset-1 ring-blue-500 scale-110' : ''}" style="background-color: ${c}" onclick="app.updateSelParam(${sel.id}, 'borderColor', '${c}')"></button>`; }).join('');
                        const badgeColor = sel.detectedColor || '#EC4899';
                        const expanded = active ? `
                            <div class="p-3 bg-gray-50 border-t border-gray-100 space-y-4">
                                <div><div class="flex justify-between mb-1 text-[10px] font-bold text-gray-500 uppercase">容許度 <span class="text-blue-600">${sel.params.tolerance}</span></div><div class="slider-group flex items-center"><button class="slider-btn text-gray-500 px-1" onclick="app.adjSlider('sel-tol-${sel.id}', -5)">-</button><input type="range" id="sel-tol-${sel.id}" min="0" max="127" value="${sel.params.tolerance}" onchange="app.updateSelParam(${sel.id}, 'tolerance', this.value)" class="h-1 bg-gray-200 rounded-lg appearance-none flex-1 accent-blue-500 mx-1"><button class="slider-btn text-gray-500 px-1" onclick="app.adjSlider('sel-tol-${sel.id}', 5)">+</button></div></div>
                                <div><div class="flex justify-between mb-1 text-[10px] font-bold text-gray-500 uppercase">擴展 <span class="text-purple-600">${sel.params.expand}px</span></div><div class="slider-group flex items-center"><button class="slider-btn text-gray-500 px-1" onclick="app.adjSlider('sel-exp-${sel.id}', -1)">-</button><input type="range" id="sel-exp-${sel.id}" min="0" max="20" value="${sel.params.expand}" onchange="app.updateSelParam(${sel.id}, 'expand', this.value)" class="h-1 bg-gray-200 rounded-lg appearance-none flex-1 accent-purple-500 mx-1"><button class="slider-btn text-gray-500 px-1" onclick="app.adjSlider('sel-exp-${sel.id}', 1)">+</button></div></div>
                                <div class="flex items-center justify-between pt-1">
                                    <label class="flex items-center text-xs text-gray-700 font-bold"><input type="checkbox" onchange="app.updateSelParam(${sel.id}, 'fillHoles', this.checked)" ${sel.params.fillHoles ? 'checked' : ''} class="mr-2 w-4 h-4">自動補洞</label>
                                    <label class="flex items-center text-xs text-gray-700 font-bold"><input type="checkbox" onchange="app.updateSelParam(${sel.id}, 'border', this.checked)" ${sel.params.border ? 'checked' : ''} class="mr-2 w-4 h-4">顯示框線</label>
                                </div>
                                ${sel.params.border ? `<div class="mt-3 pt-3 border-t border-gray-100"><div class="flex items-center justify-between mb-2 text-[10px] font-bold text-gray-500 uppercase">框線粗細<div class="slider-group flex items-center"><button class="slider-btn text-gray-500 px-1" onclick="app.adjSlider('sel-bt-inp-${sel.id}', -1)">-</button><span class="text-xs w-6 text-center font-mono font-bold">${sel.params.borderThickness}</span><button class="slider-btn text-gray-500 px-1" onclick="app.adjSlider('sel-bt-inp-${sel.id}', 1)">+</button></div><input type="range" id="sel-bt-inp-${sel.id}" min="1" max="20" value="${sel.params.borderThickness}" class="hidden" onchange="app.updateSelParam(${sel.id}, 'borderThickness', this.value)"></div><div class="flex flex-wrap gap-2 pt-1">${cols}</div></div>` : ''}
                            </div>` : '';
                        div.innerHTML = `<div class="flex items-center p-3 cursor-pointer hover:bg-gray-50 transition-colors"><div class="w-6 h-6 rounded flex items-center justify-center font-bold text-[10px] shadow-sm border border-black/10" style="background-color: ${badgeColor}; color: ${badgeColor === '#FFFFFF' ? '#000' : '#FFF'};">${i + 1}</div><div class="flex-1 ml-3 text-sm font-bold text-gray-700">岩點 #${i + 1}</div><button onclick="app.removeSel(${sel.id})" class="text-gray-400 hover:text-red-500 p-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button></div>${expanded}`;
                        list.appendChild(div);
                    });
                }
                const actO = this.state.data.objects.find(o => o.id === this.state.view.activeObjId);
                const tc = document.getElementById('text-controls');
                if (tc) {
                    if (actO && this.state.view.activeTab === 'text') {
                        tc.classList.remove('opacity-50', 'pointer-events-none');
                        const ts = document.getElementById('text-size'); if (ts) ts.value = actO.fontSize;
                        const tb = document.getElementById('text-bg-toggle');
                        if (tb) {
                            tb.checked = !!actO.bgColor;
                            document.getElementById('text-bg-track')?.classList.toggle('bg-blue-500', tb.checked);
                            document.getElementById('text-bg-dot')?.classList.toggle('translate-x-4', tb.checked);
                        }
                    } else tc.classList.add('opacity-50', 'pointer-events-none');
                }
            }
            updateSelParam(id, k, v) { const s = this.state.data.selections.find(x => x.id === id); if (s) { s.params[k] = (k === 'fillHoles' || k === 'border' || k === 'borderColor') ? v : parseInt(v); if (k === 'borderColor') { this.flags.mask = true; this.updateUI(); } else { s.mask = s.borderMask = null; this.requestWorker(s); } this.state.pushHistory(); if (k === 'border') this.updateUI(); } }
            toggleCrop() {
                let idx = (this.state.data.crop.index + 1) % CROPS.length; this.state.data.crop.index = idx;
                const crop = CROPS[idx];
                const cl = document.getElementById('crop-label'); if (cl) { cl.innerText = crop.label; cl.classList.toggle('hidden', idx === 0); }
                const cf = document.getElementById('crop-frame'), cc = document.getElementById('crop-mask-container'), cb = document.getElementById('crop-inner-backdrop'), cbg = document.getElementById('crop-canvas-bg');
                if (cf && cc && cb) {
                    if (idx === 0) { cc.classList.add('hidden'); cf.style.display = 'none'; cb.style.display = 'none'; if (cbg) cbg.style.backgroundColor = 'transparent'; document.getElementById('crop-bg-color')?.classList.add('hidden'); }
                    else {
                        cc.classList.remove('hidden'); cf.style.display = 'block'; cb.style.display = 'block';
                        cb.style.width = this.layers.width + 'px'; cb.style.height = this.layers.height + 'px';
                        cb.style.backgroundColor = this.state.data.crop.bgWhite ? 'white' : 'black';
                        if (cbg) cbg.style.backgroundColor = 'rgba(0,0,0,0.6)';
                        document.getElementById('crop-bg-color')?.classList.remove('hidden');
                        const r = document.getElementById('canvas-container').getBoundingClientRect(), aspect = crop.w / crop.h;
                        let w = r.width - 40, h = w / aspect; if (h > r.height - 40) { h = r.height - 40; w = h * aspect; }
                        cf.style.width = w + 'px'; cf.style.height = h + 'px';
                    }
                }
                if (idx !== 0) { this.setTool('hand'); this.switchTab('route'); }
            }
            toggleCropBg() { this.state.data.crop.bgWhite = !this.state.data.crop.bgWhite; const b = document.getElementById('crop-inner-backdrop'); if (b) b.style.backgroundColor = this.state.data.crop.bgWhite ? 'white' : 'black'; }
            removeSel(id) { this.state.data.selections = this.state.data.selections.filter(s => s.id !== id); if (this.state.view.activeSelId === id) this.state.view.activeSelId = null; this.flags.mask = true; this.updateUI(); this.state.pushHistory(); }
            export() {
                const outC = document.createElement('canvas'); outC.width = this.layers.width; outC.height = this.layers.height;
                const ctx = outC.getContext('2d'); ctx.drawImage(document.getElementById('layer-bg'), 0, 0); ctx.drawImage(document.getElementById('layer-mask'), 0, 0); ctx.drawImage(document.getElementById('layer-ui'), 0, 0);
                const a = document.createElement('a'); a.download = 'holdfocus_export.png'; a.href = outC.toDataURL(); a.click();
            }
        }
        document.addEventListener('DOMContentLoaded', () => { window.app = new App(); });
    </script>
</body>

</html>